// DO NOT EDIT!
// Code generated by "github.com/DAMEDIC/fhir-toolbox-go/internal/generate";
// use `make generate` to regenerate.

package capabilitiesR5

import (
	"cmp"
	"context"
	"errors"
	"fmt"
	capabilities "github.com/DAMEDIC/fhir-toolbox-go/capabilities"
	search "github.com/DAMEDIC/fhir-toolbox-go/capabilities/search"
	update "github.com/DAMEDIC/fhir-toolbox-go/capabilities/update"
	fhirpath "github.com/DAMEDIC/fhir-toolbox-go/fhirpath"
	model "github.com/DAMEDIC/fhir-toolbox-go/model"
	basic "github.com/DAMEDIC/fhir-toolbox-go/model/gen/basic"
	r5 "github.com/DAMEDIC/fhir-toolbox-go/model/gen/r5"
	ptr "github.com/DAMEDIC/fhir-toolbox-go/utils/ptr"
	"slices"
	"strings"
)

type Generic struct {
	Concrete capabilities.ConcreteCapabilities
}

func (w Generic) CapabilityStatement(ctx context.Context) (basic.CapabilityStatement, error) {
	gen, ok := w.Concrete.(capabilities.GenericCapabilities)
	if ok {
		// shortcut for the case that the underlying implementation already implements the generic API
		return gen.CapabilityStatement(ctx)
	}
	// Generate CapabilityStatement from concrete implementation
	baseCapabilityStatement, err := w.Concrete.CapabilityBase(ctx)
	if err != nil {
		return basic.CapabilityStatement{}, err
	}
	var baseUrl string
	if baseCapabilityStatement.Implementation == nil || baseCapabilityStatement.Implementation.Url == nil || baseCapabilityStatement.Implementation.Url.Value == nil {
		return basic.CapabilityStatement{}, fmt.Errorf("base CapabilityStatement must have implementation.url set for canonical SearchParameter references")
	}
	baseUrl = *baseCapabilityStatement.Implementation.Url.Value
	resourcesMap := make(map[string]basic.CapabilityStatementRestResource)
	for _, rest := range baseCapabilityStatement.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil {
				resourcesMap[*resource.Type.Value] = resource
			}
		}
	}
	var errs []error
	addInteraction := func(name string, interactionCode string) basic.CapabilityStatementRestResource {
		r, ok := resourcesMap[name]
		if !ok {
			r = basic.CapabilityStatementRestResource{Type: basic.Code{Value: &name}}
		}
		r.Interaction = append(r.Interaction, basic.CapabilityStatementRestResourceInteraction{Code: basic.Code{Value: ptr.To(interactionCode)}})
		return r
	}
	if _, ok := w.Concrete.(AccountCreate); ok {
		resourcesMap["Account"] = addInteraction("Account", "create")
	}
	if _, ok := w.Concrete.(AccountRead); ok {
		resourcesMap["Account"] = addInteraction("Account", "read")
	}
	if _, ok := w.Concrete.(AccountDelete); ok {
		resourcesMap["Account"] = addInteraction("Account", "delete")
	}
	if c, ok := w.Concrete.(AccountUpdate); ok {
		r := addInteraction("Account", "update")
		c, ok := c.(AccountUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAccount(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Account"] = r
	}
	if c, ok := w.Concrete.(AccountSearch); ok {
		c, err := c.SearchCapabilitiesAccount(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Account", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Account-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Account"] = r
		}
	}
	if _, ok := w.Concrete.(ActivityDefinitionCreate); ok {
		resourcesMap["ActivityDefinition"] = addInteraction("ActivityDefinition", "create")
	}
	if _, ok := w.Concrete.(ActivityDefinitionRead); ok {
		resourcesMap["ActivityDefinition"] = addInteraction("ActivityDefinition", "read")
	}
	if _, ok := w.Concrete.(ActivityDefinitionDelete); ok {
		resourcesMap["ActivityDefinition"] = addInteraction("ActivityDefinition", "delete")
	}
	if c, ok := w.Concrete.(ActivityDefinitionUpdate); ok {
		r := addInteraction("ActivityDefinition", "update")
		c, ok := c.(ActivityDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesActivityDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ActivityDefinition"] = r
	}
	if c, ok := w.Concrete.(ActivityDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesActivityDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ActivityDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ActivityDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ActivityDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(ActorDefinitionCreate); ok {
		resourcesMap["ActorDefinition"] = addInteraction("ActorDefinition", "create")
	}
	if _, ok := w.Concrete.(ActorDefinitionRead); ok {
		resourcesMap["ActorDefinition"] = addInteraction("ActorDefinition", "read")
	}
	if _, ok := w.Concrete.(ActorDefinitionDelete); ok {
		resourcesMap["ActorDefinition"] = addInteraction("ActorDefinition", "delete")
	}
	if c, ok := w.Concrete.(ActorDefinitionUpdate); ok {
		r := addInteraction("ActorDefinition", "update")
		c, ok := c.(ActorDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesActorDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ActorDefinition"] = r
	}
	if c, ok := w.Concrete.(ActorDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesActorDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ActorDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ActorDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ActorDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(AdministrableProductDefinitionCreate); ok {
		resourcesMap["AdministrableProductDefinition"] = addInteraction("AdministrableProductDefinition", "create")
	}
	if _, ok := w.Concrete.(AdministrableProductDefinitionRead); ok {
		resourcesMap["AdministrableProductDefinition"] = addInteraction("AdministrableProductDefinition", "read")
	}
	if _, ok := w.Concrete.(AdministrableProductDefinitionDelete); ok {
		resourcesMap["AdministrableProductDefinition"] = addInteraction("AdministrableProductDefinition", "delete")
	}
	if c, ok := w.Concrete.(AdministrableProductDefinitionUpdate); ok {
		r := addInteraction("AdministrableProductDefinition", "update")
		c, ok := c.(AdministrableProductDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAdministrableProductDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AdministrableProductDefinition"] = r
	}
	if c, ok := w.Concrete.(AdministrableProductDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesAdministrableProductDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AdministrableProductDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AdministrableProductDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AdministrableProductDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(AdverseEventCreate); ok {
		resourcesMap["AdverseEvent"] = addInteraction("AdverseEvent", "create")
	}
	if _, ok := w.Concrete.(AdverseEventRead); ok {
		resourcesMap["AdverseEvent"] = addInteraction("AdverseEvent", "read")
	}
	if _, ok := w.Concrete.(AdverseEventDelete); ok {
		resourcesMap["AdverseEvent"] = addInteraction("AdverseEvent", "delete")
	}
	if c, ok := w.Concrete.(AdverseEventUpdate); ok {
		r := addInteraction("AdverseEvent", "update")
		c, ok := c.(AdverseEventUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAdverseEvent(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AdverseEvent"] = r
	}
	if c, ok := w.Concrete.(AdverseEventSearch); ok {
		c, err := c.SearchCapabilitiesAdverseEvent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AdverseEvent", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AdverseEvent-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AdverseEvent"] = r
		}
	}
	if _, ok := w.Concrete.(AllergyIntoleranceCreate); ok {
		resourcesMap["AllergyIntolerance"] = addInteraction("AllergyIntolerance", "create")
	}
	if _, ok := w.Concrete.(AllergyIntoleranceRead); ok {
		resourcesMap["AllergyIntolerance"] = addInteraction("AllergyIntolerance", "read")
	}
	if _, ok := w.Concrete.(AllergyIntoleranceDelete); ok {
		resourcesMap["AllergyIntolerance"] = addInteraction("AllergyIntolerance", "delete")
	}
	if c, ok := w.Concrete.(AllergyIntoleranceUpdate); ok {
		r := addInteraction("AllergyIntolerance", "update")
		c, ok := c.(AllergyIntoleranceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAllergyIntolerance(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AllergyIntolerance"] = r
	}
	if c, ok := w.Concrete.(AllergyIntoleranceSearch); ok {
		c, err := c.SearchCapabilitiesAllergyIntolerance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AllergyIntolerance", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AllergyIntolerance-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AllergyIntolerance"] = r
		}
	}
	if _, ok := w.Concrete.(AppointmentCreate); ok {
		resourcesMap["Appointment"] = addInteraction("Appointment", "create")
	}
	if _, ok := w.Concrete.(AppointmentRead); ok {
		resourcesMap["Appointment"] = addInteraction("Appointment", "read")
	}
	if _, ok := w.Concrete.(AppointmentDelete); ok {
		resourcesMap["Appointment"] = addInteraction("Appointment", "delete")
	}
	if c, ok := w.Concrete.(AppointmentUpdate); ok {
		r := addInteraction("Appointment", "update")
		c, ok := c.(AppointmentUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAppointment(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Appointment"] = r
	}
	if c, ok := w.Concrete.(AppointmentSearch); ok {
		c, err := c.SearchCapabilitiesAppointment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Appointment", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Appointment-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Appointment"] = r
		}
	}
	if _, ok := w.Concrete.(AppointmentResponseCreate); ok {
		resourcesMap["AppointmentResponse"] = addInteraction("AppointmentResponse", "create")
	}
	if _, ok := w.Concrete.(AppointmentResponseRead); ok {
		resourcesMap["AppointmentResponse"] = addInteraction("AppointmentResponse", "read")
	}
	if _, ok := w.Concrete.(AppointmentResponseDelete); ok {
		resourcesMap["AppointmentResponse"] = addInteraction("AppointmentResponse", "delete")
	}
	if c, ok := w.Concrete.(AppointmentResponseUpdate); ok {
		r := addInteraction("AppointmentResponse", "update")
		c, ok := c.(AppointmentResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAppointmentResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AppointmentResponse"] = r
	}
	if c, ok := w.Concrete.(AppointmentResponseSearch); ok {
		c, err := c.SearchCapabilitiesAppointmentResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AppointmentResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AppointmentResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AppointmentResponse"] = r
		}
	}
	if _, ok := w.Concrete.(ArtifactAssessmentCreate); ok {
		resourcesMap["ArtifactAssessment"] = addInteraction("ArtifactAssessment", "create")
	}
	if _, ok := w.Concrete.(ArtifactAssessmentRead); ok {
		resourcesMap["ArtifactAssessment"] = addInteraction("ArtifactAssessment", "read")
	}
	if _, ok := w.Concrete.(ArtifactAssessmentDelete); ok {
		resourcesMap["ArtifactAssessment"] = addInteraction("ArtifactAssessment", "delete")
	}
	if c, ok := w.Concrete.(ArtifactAssessmentUpdate); ok {
		r := addInteraction("ArtifactAssessment", "update")
		c, ok := c.(ArtifactAssessmentUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesArtifactAssessment(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ArtifactAssessment"] = r
	}
	if c, ok := w.Concrete.(ArtifactAssessmentSearch); ok {
		c, err := c.SearchCapabilitiesArtifactAssessment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ArtifactAssessment", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ArtifactAssessment-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ArtifactAssessment"] = r
		}
	}
	if _, ok := w.Concrete.(AuditEventCreate); ok {
		resourcesMap["AuditEvent"] = addInteraction("AuditEvent", "create")
	}
	if _, ok := w.Concrete.(AuditEventRead); ok {
		resourcesMap["AuditEvent"] = addInteraction("AuditEvent", "read")
	}
	if _, ok := w.Concrete.(AuditEventDelete); ok {
		resourcesMap["AuditEvent"] = addInteraction("AuditEvent", "delete")
	}
	if c, ok := w.Concrete.(AuditEventUpdate); ok {
		r := addInteraction("AuditEvent", "update")
		c, ok := c.(AuditEventUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAuditEvent(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AuditEvent"] = r
	}
	if c, ok := w.Concrete.(AuditEventSearch); ok {
		c, err := c.SearchCapabilitiesAuditEvent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AuditEvent", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AuditEvent-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AuditEvent"] = r
		}
	}
	if _, ok := w.Concrete.(BasicCreate); ok {
		resourcesMap["Basic"] = addInteraction("Basic", "create")
	}
	if _, ok := w.Concrete.(BasicRead); ok {
		resourcesMap["Basic"] = addInteraction("Basic", "read")
	}
	if _, ok := w.Concrete.(BasicDelete); ok {
		resourcesMap["Basic"] = addInteraction("Basic", "delete")
	}
	if c, ok := w.Concrete.(BasicUpdate); ok {
		r := addInteraction("Basic", "update")
		c, ok := c.(BasicUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBasic(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Basic"] = r
	}
	if c, ok := w.Concrete.(BasicSearch); ok {
		c, err := c.SearchCapabilitiesBasic(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Basic", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Basic-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Basic"] = r
		}
	}
	if _, ok := w.Concrete.(BinaryCreate); ok {
		resourcesMap["Binary"] = addInteraction("Binary", "create")
	}
	if _, ok := w.Concrete.(BinaryRead); ok {
		resourcesMap["Binary"] = addInteraction("Binary", "read")
	}
	if _, ok := w.Concrete.(BinaryDelete); ok {
		resourcesMap["Binary"] = addInteraction("Binary", "delete")
	}
	if c, ok := w.Concrete.(BinaryUpdate); ok {
		r := addInteraction("Binary", "update")
		c, ok := c.(BinaryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBinary(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Binary"] = r
	}
	if c, ok := w.Concrete.(BinarySearch); ok {
		c, err := c.SearchCapabilitiesBinary(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Binary", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Binary-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Binary"] = r
		}
	}
	if _, ok := w.Concrete.(BiologicallyDerivedProductCreate); ok {
		resourcesMap["BiologicallyDerivedProduct"] = addInteraction("BiologicallyDerivedProduct", "create")
	}
	if _, ok := w.Concrete.(BiologicallyDerivedProductRead); ok {
		resourcesMap["BiologicallyDerivedProduct"] = addInteraction("BiologicallyDerivedProduct", "read")
	}
	if _, ok := w.Concrete.(BiologicallyDerivedProductDelete); ok {
		resourcesMap["BiologicallyDerivedProduct"] = addInteraction("BiologicallyDerivedProduct", "delete")
	}
	if c, ok := w.Concrete.(BiologicallyDerivedProductUpdate); ok {
		r := addInteraction("BiologicallyDerivedProduct", "update")
		c, ok := c.(BiologicallyDerivedProductUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBiologicallyDerivedProduct(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["BiologicallyDerivedProduct"] = r
	}
	if c, ok := w.Concrete.(BiologicallyDerivedProductSearch); ok {
		c, err := c.SearchCapabilitiesBiologicallyDerivedProduct(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("BiologicallyDerivedProduct", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("BiologicallyDerivedProduct-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["BiologicallyDerivedProduct"] = r
		}
	}
	if _, ok := w.Concrete.(BiologicallyDerivedProductDispenseCreate); ok {
		resourcesMap["BiologicallyDerivedProductDispense"] = addInteraction("BiologicallyDerivedProductDispense", "create")
	}
	if _, ok := w.Concrete.(BiologicallyDerivedProductDispenseRead); ok {
		resourcesMap["BiologicallyDerivedProductDispense"] = addInteraction("BiologicallyDerivedProductDispense", "read")
	}
	if _, ok := w.Concrete.(BiologicallyDerivedProductDispenseDelete); ok {
		resourcesMap["BiologicallyDerivedProductDispense"] = addInteraction("BiologicallyDerivedProductDispense", "delete")
	}
	if c, ok := w.Concrete.(BiologicallyDerivedProductDispenseUpdate); ok {
		r := addInteraction("BiologicallyDerivedProductDispense", "update")
		c, ok := c.(BiologicallyDerivedProductDispenseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBiologicallyDerivedProductDispense(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["BiologicallyDerivedProductDispense"] = r
	}
	if c, ok := w.Concrete.(BiologicallyDerivedProductDispenseSearch); ok {
		c, err := c.SearchCapabilitiesBiologicallyDerivedProductDispense(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("BiologicallyDerivedProductDispense", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("BiologicallyDerivedProductDispense-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["BiologicallyDerivedProductDispense"] = r
		}
	}
	if _, ok := w.Concrete.(BodyStructureCreate); ok {
		resourcesMap["BodyStructure"] = addInteraction("BodyStructure", "create")
	}
	if _, ok := w.Concrete.(BodyStructureRead); ok {
		resourcesMap["BodyStructure"] = addInteraction("BodyStructure", "read")
	}
	if _, ok := w.Concrete.(BodyStructureDelete); ok {
		resourcesMap["BodyStructure"] = addInteraction("BodyStructure", "delete")
	}
	if c, ok := w.Concrete.(BodyStructureUpdate); ok {
		r := addInteraction("BodyStructure", "update")
		c, ok := c.(BodyStructureUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBodyStructure(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["BodyStructure"] = r
	}
	if c, ok := w.Concrete.(BodyStructureSearch); ok {
		c, err := c.SearchCapabilitiesBodyStructure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("BodyStructure", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("BodyStructure-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["BodyStructure"] = r
		}
	}
	if _, ok := w.Concrete.(BundleCreate); ok {
		resourcesMap["Bundle"] = addInteraction("Bundle", "create")
	}
	if _, ok := w.Concrete.(BundleRead); ok {
		resourcesMap["Bundle"] = addInteraction("Bundle", "read")
	}
	if _, ok := w.Concrete.(BundleDelete); ok {
		resourcesMap["Bundle"] = addInteraction("Bundle", "delete")
	}
	if c, ok := w.Concrete.(BundleUpdate); ok {
		r := addInteraction("Bundle", "update")
		c, ok := c.(BundleUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBundle(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Bundle"] = r
	}
	if c, ok := w.Concrete.(BundleSearch); ok {
		c, err := c.SearchCapabilitiesBundle(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Bundle", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Bundle-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Bundle"] = r
		}
	}
	if _, ok := w.Concrete.(CapabilityStatementCreate); ok {
		resourcesMap["CapabilityStatement"] = addInteraction("CapabilityStatement", "create")
	}
	if _, ok := w.Concrete.(CapabilityStatementRead); ok {
		resourcesMap["CapabilityStatement"] = addInteraction("CapabilityStatement", "read")
	}
	if _, ok := w.Concrete.(CapabilityStatementDelete); ok {
		resourcesMap["CapabilityStatement"] = addInteraction("CapabilityStatement", "delete")
	}
	if c, ok := w.Concrete.(CapabilityStatementUpdate); ok {
		r := addInteraction("CapabilityStatement", "update")
		c, ok := c.(CapabilityStatementUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCapabilityStatement(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CapabilityStatement"] = r
	}
	if c, ok := w.Concrete.(CapabilityStatementSearch); ok {
		c, err := c.SearchCapabilitiesCapabilityStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CapabilityStatement", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CapabilityStatement-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CapabilityStatement"] = r
		}
	}
	if _, ok := w.Concrete.(CarePlanCreate); ok {
		resourcesMap["CarePlan"] = addInteraction("CarePlan", "create")
	}
	if _, ok := w.Concrete.(CarePlanRead); ok {
		resourcesMap["CarePlan"] = addInteraction("CarePlan", "read")
	}
	if _, ok := w.Concrete.(CarePlanDelete); ok {
		resourcesMap["CarePlan"] = addInteraction("CarePlan", "delete")
	}
	if c, ok := w.Concrete.(CarePlanUpdate); ok {
		r := addInteraction("CarePlan", "update")
		c, ok := c.(CarePlanUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCarePlan(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CarePlan"] = r
	}
	if c, ok := w.Concrete.(CarePlanSearch); ok {
		c, err := c.SearchCapabilitiesCarePlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CarePlan", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CarePlan-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CarePlan"] = r
		}
	}
	if _, ok := w.Concrete.(CareTeamCreate); ok {
		resourcesMap["CareTeam"] = addInteraction("CareTeam", "create")
	}
	if _, ok := w.Concrete.(CareTeamRead); ok {
		resourcesMap["CareTeam"] = addInteraction("CareTeam", "read")
	}
	if _, ok := w.Concrete.(CareTeamDelete); ok {
		resourcesMap["CareTeam"] = addInteraction("CareTeam", "delete")
	}
	if c, ok := w.Concrete.(CareTeamUpdate); ok {
		r := addInteraction("CareTeam", "update")
		c, ok := c.(CareTeamUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCareTeam(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CareTeam"] = r
	}
	if c, ok := w.Concrete.(CareTeamSearch); ok {
		c, err := c.SearchCapabilitiesCareTeam(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CareTeam", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CareTeam-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CareTeam"] = r
		}
	}
	if _, ok := w.Concrete.(ChargeItemCreate); ok {
		resourcesMap["ChargeItem"] = addInteraction("ChargeItem", "create")
	}
	if _, ok := w.Concrete.(ChargeItemRead); ok {
		resourcesMap["ChargeItem"] = addInteraction("ChargeItem", "read")
	}
	if _, ok := w.Concrete.(ChargeItemDelete); ok {
		resourcesMap["ChargeItem"] = addInteraction("ChargeItem", "delete")
	}
	if c, ok := w.Concrete.(ChargeItemUpdate); ok {
		r := addInteraction("ChargeItem", "update")
		c, ok := c.(ChargeItemUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesChargeItem(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ChargeItem"] = r
	}
	if c, ok := w.Concrete.(ChargeItemSearch); ok {
		c, err := c.SearchCapabilitiesChargeItem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ChargeItem", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ChargeItem-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ChargeItem"] = r
		}
	}
	if _, ok := w.Concrete.(ChargeItemDefinitionCreate); ok {
		resourcesMap["ChargeItemDefinition"] = addInteraction("ChargeItemDefinition", "create")
	}
	if _, ok := w.Concrete.(ChargeItemDefinitionRead); ok {
		resourcesMap["ChargeItemDefinition"] = addInteraction("ChargeItemDefinition", "read")
	}
	if _, ok := w.Concrete.(ChargeItemDefinitionDelete); ok {
		resourcesMap["ChargeItemDefinition"] = addInteraction("ChargeItemDefinition", "delete")
	}
	if c, ok := w.Concrete.(ChargeItemDefinitionUpdate); ok {
		r := addInteraction("ChargeItemDefinition", "update")
		c, ok := c.(ChargeItemDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesChargeItemDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ChargeItemDefinition"] = r
	}
	if c, ok := w.Concrete.(ChargeItemDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesChargeItemDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ChargeItemDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ChargeItemDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ChargeItemDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(CitationCreate); ok {
		resourcesMap["Citation"] = addInteraction("Citation", "create")
	}
	if _, ok := w.Concrete.(CitationRead); ok {
		resourcesMap["Citation"] = addInteraction("Citation", "read")
	}
	if _, ok := w.Concrete.(CitationDelete); ok {
		resourcesMap["Citation"] = addInteraction("Citation", "delete")
	}
	if c, ok := w.Concrete.(CitationUpdate); ok {
		r := addInteraction("Citation", "update")
		c, ok := c.(CitationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCitation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Citation"] = r
	}
	if c, ok := w.Concrete.(CitationSearch); ok {
		c, err := c.SearchCapabilitiesCitation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Citation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Citation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Citation"] = r
		}
	}
	if _, ok := w.Concrete.(ClaimCreate); ok {
		resourcesMap["Claim"] = addInteraction("Claim", "create")
	}
	if _, ok := w.Concrete.(ClaimRead); ok {
		resourcesMap["Claim"] = addInteraction("Claim", "read")
	}
	if _, ok := w.Concrete.(ClaimDelete); ok {
		resourcesMap["Claim"] = addInteraction("Claim", "delete")
	}
	if c, ok := w.Concrete.(ClaimUpdate); ok {
		r := addInteraction("Claim", "update")
		c, ok := c.(ClaimUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesClaim(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Claim"] = r
	}
	if c, ok := w.Concrete.(ClaimSearch); ok {
		c, err := c.SearchCapabilitiesClaim(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Claim", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Claim-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Claim"] = r
		}
	}
	if _, ok := w.Concrete.(ClaimResponseCreate); ok {
		resourcesMap["ClaimResponse"] = addInteraction("ClaimResponse", "create")
	}
	if _, ok := w.Concrete.(ClaimResponseRead); ok {
		resourcesMap["ClaimResponse"] = addInteraction("ClaimResponse", "read")
	}
	if _, ok := w.Concrete.(ClaimResponseDelete); ok {
		resourcesMap["ClaimResponse"] = addInteraction("ClaimResponse", "delete")
	}
	if c, ok := w.Concrete.(ClaimResponseUpdate); ok {
		r := addInteraction("ClaimResponse", "update")
		c, ok := c.(ClaimResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesClaimResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ClaimResponse"] = r
	}
	if c, ok := w.Concrete.(ClaimResponseSearch); ok {
		c, err := c.SearchCapabilitiesClaimResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ClaimResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ClaimResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ClaimResponse"] = r
		}
	}
	if _, ok := w.Concrete.(ClinicalImpressionCreate); ok {
		resourcesMap["ClinicalImpression"] = addInteraction("ClinicalImpression", "create")
	}
	if _, ok := w.Concrete.(ClinicalImpressionRead); ok {
		resourcesMap["ClinicalImpression"] = addInteraction("ClinicalImpression", "read")
	}
	if _, ok := w.Concrete.(ClinicalImpressionDelete); ok {
		resourcesMap["ClinicalImpression"] = addInteraction("ClinicalImpression", "delete")
	}
	if c, ok := w.Concrete.(ClinicalImpressionUpdate); ok {
		r := addInteraction("ClinicalImpression", "update")
		c, ok := c.(ClinicalImpressionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesClinicalImpression(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ClinicalImpression"] = r
	}
	if c, ok := w.Concrete.(ClinicalImpressionSearch); ok {
		c, err := c.SearchCapabilitiesClinicalImpression(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ClinicalImpression", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ClinicalImpression-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ClinicalImpression"] = r
		}
	}
	if _, ok := w.Concrete.(ClinicalUseDefinitionCreate); ok {
		resourcesMap["ClinicalUseDefinition"] = addInteraction("ClinicalUseDefinition", "create")
	}
	if _, ok := w.Concrete.(ClinicalUseDefinitionRead); ok {
		resourcesMap["ClinicalUseDefinition"] = addInteraction("ClinicalUseDefinition", "read")
	}
	if _, ok := w.Concrete.(ClinicalUseDefinitionDelete); ok {
		resourcesMap["ClinicalUseDefinition"] = addInteraction("ClinicalUseDefinition", "delete")
	}
	if c, ok := w.Concrete.(ClinicalUseDefinitionUpdate); ok {
		r := addInteraction("ClinicalUseDefinition", "update")
		c, ok := c.(ClinicalUseDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesClinicalUseDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ClinicalUseDefinition"] = r
	}
	if c, ok := w.Concrete.(ClinicalUseDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesClinicalUseDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ClinicalUseDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ClinicalUseDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ClinicalUseDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(CodeSystemCreate); ok {
		resourcesMap["CodeSystem"] = addInteraction("CodeSystem", "create")
	}
	if _, ok := w.Concrete.(CodeSystemRead); ok {
		resourcesMap["CodeSystem"] = addInteraction("CodeSystem", "read")
	}
	if _, ok := w.Concrete.(CodeSystemDelete); ok {
		resourcesMap["CodeSystem"] = addInteraction("CodeSystem", "delete")
	}
	if c, ok := w.Concrete.(CodeSystemUpdate); ok {
		r := addInteraction("CodeSystem", "update")
		c, ok := c.(CodeSystemUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCodeSystem(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CodeSystem"] = r
	}
	if c, ok := w.Concrete.(CodeSystemSearch); ok {
		c, err := c.SearchCapabilitiesCodeSystem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CodeSystem", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CodeSystem-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CodeSystem"] = r
		}
	}
	if _, ok := w.Concrete.(CommunicationCreate); ok {
		resourcesMap["Communication"] = addInteraction("Communication", "create")
	}
	if _, ok := w.Concrete.(CommunicationRead); ok {
		resourcesMap["Communication"] = addInteraction("Communication", "read")
	}
	if _, ok := w.Concrete.(CommunicationDelete); ok {
		resourcesMap["Communication"] = addInteraction("Communication", "delete")
	}
	if c, ok := w.Concrete.(CommunicationUpdate); ok {
		r := addInteraction("Communication", "update")
		c, ok := c.(CommunicationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCommunication(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Communication"] = r
	}
	if c, ok := w.Concrete.(CommunicationSearch); ok {
		c, err := c.SearchCapabilitiesCommunication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Communication", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Communication-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Communication"] = r
		}
	}
	if _, ok := w.Concrete.(CommunicationRequestCreate); ok {
		resourcesMap["CommunicationRequest"] = addInteraction("CommunicationRequest", "create")
	}
	if _, ok := w.Concrete.(CommunicationRequestRead); ok {
		resourcesMap["CommunicationRequest"] = addInteraction("CommunicationRequest", "read")
	}
	if _, ok := w.Concrete.(CommunicationRequestDelete); ok {
		resourcesMap["CommunicationRequest"] = addInteraction("CommunicationRequest", "delete")
	}
	if c, ok := w.Concrete.(CommunicationRequestUpdate); ok {
		r := addInteraction("CommunicationRequest", "update")
		c, ok := c.(CommunicationRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCommunicationRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CommunicationRequest"] = r
	}
	if c, ok := w.Concrete.(CommunicationRequestSearch); ok {
		c, err := c.SearchCapabilitiesCommunicationRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CommunicationRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CommunicationRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CommunicationRequest"] = r
		}
	}
	if _, ok := w.Concrete.(CompartmentDefinitionCreate); ok {
		resourcesMap["CompartmentDefinition"] = addInteraction("CompartmentDefinition", "create")
	}
	if _, ok := w.Concrete.(CompartmentDefinitionRead); ok {
		resourcesMap["CompartmentDefinition"] = addInteraction("CompartmentDefinition", "read")
	}
	if _, ok := w.Concrete.(CompartmentDefinitionDelete); ok {
		resourcesMap["CompartmentDefinition"] = addInteraction("CompartmentDefinition", "delete")
	}
	if c, ok := w.Concrete.(CompartmentDefinitionUpdate); ok {
		r := addInteraction("CompartmentDefinition", "update")
		c, ok := c.(CompartmentDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCompartmentDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CompartmentDefinition"] = r
	}
	if c, ok := w.Concrete.(CompartmentDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesCompartmentDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CompartmentDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CompartmentDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CompartmentDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(CompositionCreate); ok {
		resourcesMap["Composition"] = addInteraction("Composition", "create")
	}
	if _, ok := w.Concrete.(CompositionRead); ok {
		resourcesMap["Composition"] = addInteraction("Composition", "read")
	}
	if _, ok := w.Concrete.(CompositionDelete); ok {
		resourcesMap["Composition"] = addInteraction("Composition", "delete")
	}
	if c, ok := w.Concrete.(CompositionUpdate); ok {
		r := addInteraction("Composition", "update")
		c, ok := c.(CompositionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesComposition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Composition"] = r
	}
	if c, ok := w.Concrete.(CompositionSearch); ok {
		c, err := c.SearchCapabilitiesComposition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Composition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Composition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Composition"] = r
		}
	}
	if _, ok := w.Concrete.(ConceptMapCreate); ok {
		resourcesMap["ConceptMap"] = addInteraction("ConceptMap", "create")
	}
	if _, ok := w.Concrete.(ConceptMapRead); ok {
		resourcesMap["ConceptMap"] = addInteraction("ConceptMap", "read")
	}
	if _, ok := w.Concrete.(ConceptMapDelete); ok {
		resourcesMap["ConceptMap"] = addInteraction("ConceptMap", "delete")
	}
	if c, ok := w.Concrete.(ConceptMapUpdate); ok {
		r := addInteraction("ConceptMap", "update")
		c, ok := c.(ConceptMapUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesConceptMap(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ConceptMap"] = r
	}
	if c, ok := w.Concrete.(ConceptMapSearch); ok {
		c, err := c.SearchCapabilitiesConceptMap(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ConceptMap", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ConceptMap-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ConceptMap"] = r
		}
	}
	if _, ok := w.Concrete.(ConditionCreate); ok {
		resourcesMap["Condition"] = addInteraction("Condition", "create")
	}
	if _, ok := w.Concrete.(ConditionRead); ok {
		resourcesMap["Condition"] = addInteraction("Condition", "read")
	}
	if _, ok := w.Concrete.(ConditionDelete); ok {
		resourcesMap["Condition"] = addInteraction("Condition", "delete")
	}
	if c, ok := w.Concrete.(ConditionUpdate); ok {
		r := addInteraction("Condition", "update")
		c, ok := c.(ConditionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCondition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Condition"] = r
	}
	if c, ok := w.Concrete.(ConditionSearch); ok {
		c, err := c.SearchCapabilitiesCondition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Condition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Condition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Condition"] = r
		}
	}
	if _, ok := w.Concrete.(ConditionDefinitionCreate); ok {
		resourcesMap["ConditionDefinition"] = addInteraction("ConditionDefinition", "create")
	}
	if _, ok := w.Concrete.(ConditionDefinitionRead); ok {
		resourcesMap["ConditionDefinition"] = addInteraction("ConditionDefinition", "read")
	}
	if _, ok := w.Concrete.(ConditionDefinitionDelete); ok {
		resourcesMap["ConditionDefinition"] = addInteraction("ConditionDefinition", "delete")
	}
	if c, ok := w.Concrete.(ConditionDefinitionUpdate); ok {
		r := addInteraction("ConditionDefinition", "update")
		c, ok := c.(ConditionDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesConditionDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ConditionDefinition"] = r
	}
	if c, ok := w.Concrete.(ConditionDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesConditionDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ConditionDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ConditionDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ConditionDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(ConsentCreate); ok {
		resourcesMap["Consent"] = addInteraction("Consent", "create")
	}
	if _, ok := w.Concrete.(ConsentRead); ok {
		resourcesMap["Consent"] = addInteraction("Consent", "read")
	}
	if _, ok := w.Concrete.(ConsentDelete); ok {
		resourcesMap["Consent"] = addInteraction("Consent", "delete")
	}
	if c, ok := w.Concrete.(ConsentUpdate); ok {
		r := addInteraction("Consent", "update")
		c, ok := c.(ConsentUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesConsent(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Consent"] = r
	}
	if c, ok := w.Concrete.(ConsentSearch); ok {
		c, err := c.SearchCapabilitiesConsent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Consent", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Consent-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Consent"] = r
		}
	}
	if _, ok := w.Concrete.(ContractCreate); ok {
		resourcesMap["Contract"] = addInteraction("Contract", "create")
	}
	if _, ok := w.Concrete.(ContractRead); ok {
		resourcesMap["Contract"] = addInteraction("Contract", "read")
	}
	if _, ok := w.Concrete.(ContractDelete); ok {
		resourcesMap["Contract"] = addInteraction("Contract", "delete")
	}
	if c, ok := w.Concrete.(ContractUpdate); ok {
		r := addInteraction("Contract", "update")
		c, ok := c.(ContractUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesContract(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Contract"] = r
	}
	if c, ok := w.Concrete.(ContractSearch); ok {
		c, err := c.SearchCapabilitiesContract(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Contract", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Contract-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Contract"] = r
		}
	}
	if _, ok := w.Concrete.(CoverageCreate); ok {
		resourcesMap["Coverage"] = addInteraction("Coverage", "create")
	}
	if _, ok := w.Concrete.(CoverageRead); ok {
		resourcesMap["Coverage"] = addInteraction("Coverage", "read")
	}
	if _, ok := w.Concrete.(CoverageDelete); ok {
		resourcesMap["Coverage"] = addInteraction("Coverage", "delete")
	}
	if c, ok := w.Concrete.(CoverageUpdate); ok {
		r := addInteraction("Coverage", "update")
		c, ok := c.(CoverageUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCoverage(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Coverage"] = r
	}
	if c, ok := w.Concrete.(CoverageSearch); ok {
		c, err := c.SearchCapabilitiesCoverage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Coverage", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Coverage-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Coverage"] = r
		}
	}
	if _, ok := w.Concrete.(CoverageEligibilityRequestCreate); ok {
		resourcesMap["CoverageEligibilityRequest"] = addInteraction("CoverageEligibilityRequest", "create")
	}
	if _, ok := w.Concrete.(CoverageEligibilityRequestRead); ok {
		resourcesMap["CoverageEligibilityRequest"] = addInteraction("CoverageEligibilityRequest", "read")
	}
	if _, ok := w.Concrete.(CoverageEligibilityRequestDelete); ok {
		resourcesMap["CoverageEligibilityRequest"] = addInteraction("CoverageEligibilityRequest", "delete")
	}
	if c, ok := w.Concrete.(CoverageEligibilityRequestUpdate); ok {
		r := addInteraction("CoverageEligibilityRequest", "update")
		c, ok := c.(CoverageEligibilityRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCoverageEligibilityRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CoverageEligibilityRequest"] = r
	}
	if c, ok := w.Concrete.(CoverageEligibilityRequestSearch); ok {
		c, err := c.SearchCapabilitiesCoverageEligibilityRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CoverageEligibilityRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CoverageEligibilityRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CoverageEligibilityRequest"] = r
		}
	}
	if _, ok := w.Concrete.(CoverageEligibilityResponseCreate); ok {
		resourcesMap["CoverageEligibilityResponse"] = addInteraction("CoverageEligibilityResponse", "create")
	}
	if _, ok := w.Concrete.(CoverageEligibilityResponseRead); ok {
		resourcesMap["CoverageEligibilityResponse"] = addInteraction("CoverageEligibilityResponse", "read")
	}
	if _, ok := w.Concrete.(CoverageEligibilityResponseDelete); ok {
		resourcesMap["CoverageEligibilityResponse"] = addInteraction("CoverageEligibilityResponse", "delete")
	}
	if c, ok := w.Concrete.(CoverageEligibilityResponseUpdate); ok {
		r := addInteraction("CoverageEligibilityResponse", "update")
		c, ok := c.(CoverageEligibilityResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCoverageEligibilityResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CoverageEligibilityResponse"] = r
	}
	if c, ok := w.Concrete.(CoverageEligibilityResponseSearch); ok {
		c, err := c.SearchCapabilitiesCoverageEligibilityResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CoverageEligibilityResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CoverageEligibilityResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CoverageEligibilityResponse"] = r
		}
	}
	if _, ok := w.Concrete.(DetectedIssueCreate); ok {
		resourcesMap["DetectedIssue"] = addInteraction("DetectedIssue", "create")
	}
	if _, ok := w.Concrete.(DetectedIssueRead); ok {
		resourcesMap["DetectedIssue"] = addInteraction("DetectedIssue", "read")
	}
	if _, ok := w.Concrete.(DetectedIssueDelete); ok {
		resourcesMap["DetectedIssue"] = addInteraction("DetectedIssue", "delete")
	}
	if c, ok := w.Concrete.(DetectedIssueUpdate); ok {
		r := addInteraction("DetectedIssue", "update")
		c, ok := c.(DetectedIssueUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDetectedIssue(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DetectedIssue"] = r
	}
	if c, ok := w.Concrete.(DetectedIssueSearch); ok {
		c, err := c.SearchCapabilitiesDetectedIssue(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DetectedIssue", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DetectedIssue-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DetectedIssue"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceCreate); ok {
		resourcesMap["Device"] = addInteraction("Device", "create")
	}
	if _, ok := w.Concrete.(DeviceRead); ok {
		resourcesMap["Device"] = addInteraction("Device", "read")
	}
	if _, ok := w.Concrete.(DeviceDelete); ok {
		resourcesMap["Device"] = addInteraction("Device", "delete")
	}
	if c, ok := w.Concrete.(DeviceUpdate); ok {
		r := addInteraction("Device", "update")
		c, ok := c.(DeviceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDevice(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Device"] = r
	}
	if c, ok := w.Concrete.(DeviceSearch); ok {
		c, err := c.SearchCapabilitiesDevice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Device", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Device-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Device"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceAssociationCreate); ok {
		resourcesMap["DeviceAssociation"] = addInteraction("DeviceAssociation", "create")
	}
	if _, ok := w.Concrete.(DeviceAssociationRead); ok {
		resourcesMap["DeviceAssociation"] = addInteraction("DeviceAssociation", "read")
	}
	if _, ok := w.Concrete.(DeviceAssociationDelete); ok {
		resourcesMap["DeviceAssociation"] = addInteraction("DeviceAssociation", "delete")
	}
	if c, ok := w.Concrete.(DeviceAssociationUpdate); ok {
		r := addInteraction("DeviceAssociation", "update")
		c, ok := c.(DeviceAssociationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceAssociation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceAssociation"] = r
	}
	if c, ok := w.Concrete.(DeviceAssociationSearch); ok {
		c, err := c.SearchCapabilitiesDeviceAssociation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceAssociation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceAssociation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceAssociation"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceDefinitionCreate); ok {
		resourcesMap["DeviceDefinition"] = addInteraction("DeviceDefinition", "create")
	}
	if _, ok := w.Concrete.(DeviceDefinitionRead); ok {
		resourcesMap["DeviceDefinition"] = addInteraction("DeviceDefinition", "read")
	}
	if _, ok := w.Concrete.(DeviceDefinitionDelete); ok {
		resourcesMap["DeviceDefinition"] = addInteraction("DeviceDefinition", "delete")
	}
	if c, ok := w.Concrete.(DeviceDefinitionUpdate); ok {
		r := addInteraction("DeviceDefinition", "update")
		c, ok := c.(DeviceDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceDefinition"] = r
	}
	if c, ok := w.Concrete.(DeviceDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesDeviceDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceDispenseCreate); ok {
		resourcesMap["DeviceDispense"] = addInteraction("DeviceDispense", "create")
	}
	if _, ok := w.Concrete.(DeviceDispenseRead); ok {
		resourcesMap["DeviceDispense"] = addInteraction("DeviceDispense", "read")
	}
	if _, ok := w.Concrete.(DeviceDispenseDelete); ok {
		resourcesMap["DeviceDispense"] = addInteraction("DeviceDispense", "delete")
	}
	if c, ok := w.Concrete.(DeviceDispenseUpdate); ok {
		r := addInteraction("DeviceDispense", "update")
		c, ok := c.(DeviceDispenseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceDispense(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceDispense"] = r
	}
	if c, ok := w.Concrete.(DeviceDispenseSearch); ok {
		c, err := c.SearchCapabilitiesDeviceDispense(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceDispense", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceDispense-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceDispense"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceMetricCreate); ok {
		resourcesMap["DeviceMetric"] = addInteraction("DeviceMetric", "create")
	}
	if _, ok := w.Concrete.(DeviceMetricRead); ok {
		resourcesMap["DeviceMetric"] = addInteraction("DeviceMetric", "read")
	}
	if _, ok := w.Concrete.(DeviceMetricDelete); ok {
		resourcesMap["DeviceMetric"] = addInteraction("DeviceMetric", "delete")
	}
	if c, ok := w.Concrete.(DeviceMetricUpdate); ok {
		r := addInteraction("DeviceMetric", "update")
		c, ok := c.(DeviceMetricUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceMetric(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceMetric"] = r
	}
	if c, ok := w.Concrete.(DeviceMetricSearch); ok {
		c, err := c.SearchCapabilitiesDeviceMetric(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceMetric", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceMetric-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceMetric"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceRequestCreate); ok {
		resourcesMap["DeviceRequest"] = addInteraction("DeviceRequest", "create")
	}
	if _, ok := w.Concrete.(DeviceRequestRead); ok {
		resourcesMap["DeviceRequest"] = addInteraction("DeviceRequest", "read")
	}
	if _, ok := w.Concrete.(DeviceRequestDelete); ok {
		resourcesMap["DeviceRequest"] = addInteraction("DeviceRequest", "delete")
	}
	if c, ok := w.Concrete.(DeviceRequestUpdate); ok {
		r := addInteraction("DeviceRequest", "update")
		c, ok := c.(DeviceRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceRequest"] = r
	}
	if c, ok := w.Concrete.(DeviceRequestSearch); ok {
		c, err := c.SearchCapabilitiesDeviceRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceRequest"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceUsageCreate); ok {
		resourcesMap["DeviceUsage"] = addInteraction("DeviceUsage", "create")
	}
	if _, ok := w.Concrete.(DeviceUsageRead); ok {
		resourcesMap["DeviceUsage"] = addInteraction("DeviceUsage", "read")
	}
	if _, ok := w.Concrete.(DeviceUsageDelete); ok {
		resourcesMap["DeviceUsage"] = addInteraction("DeviceUsage", "delete")
	}
	if c, ok := w.Concrete.(DeviceUsageUpdate); ok {
		r := addInteraction("DeviceUsage", "update")
		c, ok := c.(DeviceUsageUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceUsage(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceUsage"] = r
	}
	if c, ok := w.Concrete.(DeviceUsageSearch); ok {
		c, err := c.SearchCapabilitiesDeviceUsage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceUsage", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceUsage-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceUsage"] = r
		}
	}
	if _, ok := w.Concrete.(DiagnosticReportCreate); ok {
		resourcesMap["DiagnosticReport"] = addInteraction("DiagnosticReport", "create")
	}
	if _, ok := w.Concrete.(DiagnosticReportRead); ok {
		resourcesMap["DiagnosticReport"] = addInteraction("DiagnosticReport", "read")
	}
	if _, ok := w.Concrete.(DiagnosticReportDelete); ok {
		resourcesMap["DiagnosticReport"] = addInteraction("DiagnosticReport", "delete")
	}
	if c, ok := w.Concrete.(DiagnosticReportUpdate); ok {
		r := addInteraction("DiagnosticReport", "update")
		c, ok := c.(DiagnosticReportUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDiagnosticReport(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DiagnosticReport"] = r
	}
	if c, ok := w.Concrete.(DiagnosticReportSearch); ok {
		c, err := c.SearchCapabilitiesDiagnosticReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DiagnosticReport", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DiagnosticReport-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DiagnosticReport"] = r
		}
	}
	if _, ok := w.Concrete.(DocumentReferenceCreate); ok {
		resourcesMap["DocumentReference"] = addInteraction("DocumentReference", "create")
	}
	if _, ok := w.Concrete.(DocumentReferenceRead); ok {
		resourcesMap["DocumentReference"] = addInteraction("DocumentReference", "read")
	}
	if _, ok := w.Concrete.(DocumentReferenceDelete); ok {
		resourcesMap["DocumentReference"] = addInteraction("DocumentReference", "delete")
	}
	if c, ok := w.Concrete.(DocumentReferenceUpdate); ok {
		r := addInteraction("DocumentReference", "update")
		c, ok := c.(DocumentReferenceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDocumentReference(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DocumentReference"] = r
	}
	if c, ok := w.Concrete.(DocumentReferenceSearch); ok {
		c, err := c.SearchCapabilitiesDocumentReference(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DocumentReference", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DocumentReference-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DocumentReference"] = r
		}
	}
	if _, ok := w.Concrete.(EncounterCreate); ok {
		resourcesMap["Encounter"] = addInteraction("Encounter", "create")
	}
	if _, ok := w.Concrete.(EncounterRead); ok {
		resourcesMap["Encounter"] = addInteraction("Encounter", "read")
	}
	if _, ok := w.Concrete.(EncounterDelete); ok {
		resourcesMap["Encounter"] = addInteraction("Encounter", "delete")
	}
	if c, ok := w.Concrete.(EncounterUpdate); ok {
		r := addInteraction("Encounter", "update")
		c, ok := c.(EncounterUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEncounter(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Encounter"] = r
	}
	if c, ok := w.Concrete.(EncounterSearch); ok {
		c, err := c.SearchCapabilitiesEncounter(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Encounter", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Encounter-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Encounter"] = r
		}
	}
	if _, ok := w.Concrete.(EncounterHistoryCreate); ok {
		resourcesMap["EncounterHistory"] = addInteraction("EncounterHistory", "create")
	}
	if _, ok := w.Concrete.(EncounterHistoryRead); ok {
		resourcesMap["EncounterHistory"] = addInteraction("EncounterHistory", "read")
	}
	if _, ok := w.Concrete.(EncounterHistoryDelete); ok {
		resourcesMap["EncounterHistory"] = addInteraction("EncounterHistory", "delete")
	}
	if c, ok := w.Concrete.(EncounterHistoryUpdate); ok {
		r := addInteraction("EncounterHistory", "update")
		c, ok := c.(EncounterHistoryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEncounterHistory(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EncounterHistory"] = r
	}
	if c, ok := w.Concrete.(EncounterHistorySearch); ok {
		c, err := c.SearchCapabilitiesEncounterHistory(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EncounterHistory", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EncounterHistory-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EncounterHistory"] = r
		}
	}
	if _, ok := w.Concrete.(EndpointCreate); ok {
		resourcesMap["Endpoint"] = addInteraction("Endpoint", "create")
	}
	if _, ok := w.Concrete.(EndpointRead); ok {
		resourcesMap["Endpoint"] = addInteraction("Endpoint", "read")
	}
	if _, ok := w.Concrete.(EndpointDelete); ok {
		resourcesMap["Endpoint"] = addInteraction("Endpoint", "delete")
	}
	if c, ok := w.Concrete.(EndpointUpdate); ok {
		r := addInteraction("Endpoint", "update")
		c, ok := c.(EndpointUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEndpoint(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Endpoint"] = r
	}
	if c, ok := w.Concrete.(EndpointSearch); ok {
		c, err := c.SearchCapabilitiesEndpoint(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Endpoint", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Endpoint-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Endpoint"] = r
		}
	}
	if _, ok := w.Concrete.(EnrollmentRequestCreate); ok {
		resourcesMap["EnrollmentRequest"] = addInteraction("EnrollmentRequest", "create")
	}
	if _, ok := w.Concrete.(EnrollmentRequestRead); ok {
		resourcesMap["EnrollmentRequest"] = addInteraction("EnrollmentRequest", "read")
	}
	if _, ok := w.Concrete.(EnrollmentRequestDelete); ok {
		resourcesMap["EnrollmentRequest"] = addInteraction("EnrollmentRequest", "delete")
	}
	if c, ok := w.Concrete.(EnrollmentRequestUpdate); ok {
		r := addInteraction("EnrollmentRequest", "update")
		c, ok := c.(EnrollmentRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEnrollmentRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EnrollmentRequest"] = r
	}
	if c, ok := w.Concrete.(EnrollmentRequestSearch); ok {
		c, err := c.SearchCapabilitiesEnrollmentRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EnrollmentRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EnrollmentRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EnrollmentRequest"] = r
		}
	}
	if _, ok := w.Concrete.(EnrollmentResponseCreate); ok {
		resourcesMap["EnrollmentResponse"] = addInteraction("EnrollmentResponse", "create")
	}
	if _, ok := w.Concrete.(EnrollmentResponseRead); ok {
		resourcesMap["EnrollmentResponse"] = addInteraction("EnrollmentResponse", "read")
	}
	if _, ok := w.Concrete.(EnrollmentResponseDelete); ok {
		resourcesMap["EnrollmentResponse"] = addInteraction("EnrollmentResponse", "delete")
	}
	if c, ok := w.Concrete.(EnrollmentResponseUpdate); ok {
		r := addInteraction("EnrollmentResponse", "update")
		c, ok := c.(EnrollmentResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEnrollmentResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EnrollmentResponse"] = r
	}
	if c, ok := w.Concrete.(EnrollmentResponseSearch); ok {
		c, err := c.SearchCapabilitiesEnrollmentResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EnrollmentResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EnrollmentResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EnrollmentResponse"] = r
		}
	}
	if _, ok := w.Concrete.(EpisodeOfCareCreate); ok {
		resourcesMap["EpisodeOfCare"] = addInteraction("EpisodeOfCare", "create")
	}
	if _, ok := w.Concrete.(EpisodeOfCareRead); ok {
		resourcesMap["EpisodeOfCare"] = addInteraction("EpisodeOfCare", "read")
	}
	if _, ok := w.Concrete.(EpisodeOfCareDelete); ok {
		resourcesMap["EpisodeOfCare"] = addInteraction("EpisodeOfCare", "delete")
	}
	if c, ok := w.Concrete.(EpisodeOfCareUpdate); ok {
		r := addInteraction("EpisodeOfCare", "update")
		c, ok := c.(EpisodeOfCareUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEpisodeOfCare(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EpisodeOfCare"] = r
	}
	if c, ok := w.Concrete.(EpisodeOfCareSearch); ok {
		c, err := c.SearchCapabilitiesEpisodeOfCare(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EpisodeOfCare", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EpisodeOfCare-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EpisodeOfCare"] = r
		}
	}
	if _, ok := w.Concrete.(EventDefinitionCreate); ok {
		resourcesMap["EventDefinition"] = addInteraction("EventDefinition", "create")
	}
	if _, ok := w.Concrete.(EventDefinitionRead); ok {
		resourcesMap["EventDefinition"] = addInteraction("EventDefinition", "read")
	}
	if _, ok := w.Concrete.(EventDefinitionDelete); ok {
		resourcesMap["EventDefinition"] = addInteraction("EventDefinition", "delete")
	}
	if c, ok := w.Concrete.(EventDefinitionUpdate); ok {
		r := addInteraction("EventDefinition", "update")
		c, ok := c.(EventDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEventDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EventDefinition"] = r
	}
	if c, ok := w.Concrete.(EventDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesEventDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EventDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EventDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EventDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(EvidenceCreate); ok {
		resourcesMap["Evidence"] = addInteraction("Evidence", "create")
	}
	if _, ok := w.Concrete.(EvidenceRead); ok {
		resourcesMap["Evidence"] = addInteraction("Evidence", "read")
	}
	if _, ok := w.Concrete.(EvidenceDelete); ok {
		resourcesMap["Evidence"] = addInteraction("Evidence", "delete")
	}
	if c, ok := w.Concrete.(EvidenceUpdate); ok {
		r := addInteraction("Evidence", "update")
		c, ok := c.(EvidenceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEvidence(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Evidence"] = r
	}
	if c, ok := w.Concrete.(EvidenceSearch); ok {
		c, err := c.SearchCapabilitiesEvidence(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Evidence", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Evidence-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Evidence"] = r
		}
	}
	if _, ok := w.Concrete.(EvidenceReportCreate); ok {
		resourcesMap["EvidenceReport"] = addInteraction("EvidenceReport", "create")
	}
	if _, ok := w.Concrete.(EvidenceReportRead); ok {
		resourcesMap["EvidenceReport"] = addInteraction("EvidenceReport", "read")
	}
	if _, ok := w.Concrete.(EvidenceReportDelete); ok {
		resourcesMap["EvidenceReport"] = addInteraction("EvidenceReport", "delete")
	}
	if c, ok := w.Concrete.(EvidenceReportUpdate); ok {
		r := addInteraction("EvidenceReport", "update")
		c, ok := c.(EvidenceReportUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEvidenceReport(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EvidenceReport"] = r
	}
	if c, ok := w.Concrete.(EvidenceReportSearch); ok {
		c, err := c.SearchCapabilitiesEvidenceReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EvidenceReport", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EvidenceReport-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EvidenceReport"] = r
		}
	}
	if _, ok := w.Concrete.(EvidenceVariableCreate); ok {
		resourcesMap["EvidenceVariable"] = addInteraction("EvidenceVariable", "create")
	}
	if _, ok := w.Concrete.(EvidenceVariableRead); ok {
		resourcesMap["EvidenceVariable"] = addInteraction("EvidenceVariable", "read")
	}
	if _, ok := w.Concrete.(EvidenceVariableDelete); ok {
		resourcesMap["EvidenceVariable"] = addInteraction("EvidenceVariable", "delete")
	}
	if c, ok := w.Concrete.(EvidenceVariableUpdate); ok {
		r := addInteraction("EvidenceVariable", "update")
		c, ok := c.(EvidenceVariableUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEvidenceVariable(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EvidenceVariable"] = r
	}
	if c, ok := w.Concrete.(EvidenceVariableSearch); ok {
		c, err := c.SearchCapabilitiesEvidenceVariable(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EvidenceVariable", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EvidenceVariable-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EvidenceVariable"] = r
		}
	}
	if _, ok := w.Concrete.(ExampleScenarioCreate); ok {
		resourcesMap["ExampleScenario"] = addInteraction("ExampleScenario", "create")
	}
	if _, ok := w.Concrete.(ExampleScenarioRead); ok {
		resourcesMap["ExampleScenario"] = addInteraction("ExampleScenario", "read")
	}
	if _, ok := w.Concrete.(ExampleScenarioDelete); ok {
		resourcesMap["ExampleScenario"] = addInteraction("ExampleScenario", "delete")
	}
	if c, ok := w.Concrete.(ExampleScenarioUpdate); ok {
		r := addInteraction("ExampleScenario", "update")
		c, ok := c.(ExampleScenarioUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesExampleScenario(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ExampleScenario"] = r
	}
	if c, ok := w.Concrete.(ExampleScenarioSearch); ok {
		c, err := c.SearchCapabilitiesExampleScenario(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ExampleScenario", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ExampleScenario-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ExampleScenario"] = r
		}
	}
	if _, ok := w.Concrete.(ExplanationOfBenefitCreate); ok {
		resourcesMap["ExplanationOfBenefit"] = addInteraction("ExplanationOfBenefit", "create")
	}
	if _, ok := w.Concrete.(ExplanationOfBenefitRead); ok {
		resourcesMap["ExplanationOfBenefit"] = addInteraction("ExplanationOfBenefit", "read")
	}
	if _, ok := w.Concrete.(ExplanationOfBenefitDelete); ok {
		resourcesMap["ExplanationOfBenefit"] = addInteraction("ExplanationOfBenefit", "delete")
	}
	if c, ok := w.Concrete.(ExplanationOfBenefitUpdate); ok {
		r := addInteraction("ExplanationOfBenefit", "update")
		c, ok := c.(ExplanationOfBenefitUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesExplanationOfBenefit(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ExplanationOfBenefit"] = r
	}
	if c, ok := w.Concrete.(ExplanationOfBenefitSearch); ok {
		c, err := c.SearchCapabilitiesExplanationOfBenefit(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ExplanationOfBenefit", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ExplanationOfBenefit-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ExplanationOfBenefit"] = r
		}
	}
	if _, ok := w.Concrete.(FamilyMemberHistoryCreate); ok {
		resourcesMap["FamilyMemberHistory"] = addInteraction("FamilyMemberHistory", "create")
	}
	if _, ok := w.Concrete.(FamilyMemberHistoryRead); ok {
		resourcesMap["FamilyMemberHistory"] = addInteraction("FamilyMemberHistory", "read")
	}
	if _, ok := w.Concrete.(FamilyMemberHistoryDelete); ok {
		resourcesMap["FamilyMemberHistory"] = addInteraction("FamilyMemberHistory", "delete")
	}
	if c, ok := w.Concrete.(FamilyMemberHistoryUpdate); ok {
		r := addInteraction("FamilyMemberHistory", "update")
		c, ok := c.(FamilyMemberHistoryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesFamilyMemberHistory(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["FamilyMemberHistory"] = r
	}
	if c, ok := w.Concrete.(FamilyMemberHistorySearch); ok {
		c, err := c.SearchCapabilitiesFamilyMemberHistory(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("FamilyMemberHistory", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("FamilyMemberHistory-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["FamilyMemberHistory"] = r
		}
	}
	if _, ok := w.Concrete.(FlagCreate); ok {
		resourcesMap["Flag"] = addInteraction("Flag", "create")
	}
	if _, ok := w.Concrete.(FlagRead); ok {
		resourcesMap["Flag"] = addInteraction("Flag", "read")
	}
	if _, ok := w.Concrete.(FlagDelete); ok {
		resourcesMap["Flag"] = addInteraction("Flag", "delete")
	}
	if c, ok := w.Concrete.(FlagUpdate); ok {
		r := addInteraction("Flag", "update")
		c, ok := c.(FlagUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesFlag(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Flag"] = r
	}
	if c, ok := w.Concrete.(FlagSearch); ok {
		c, err := c.SearchCapabilitiesFlag(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Flag", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Flag-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Flag"] = r
		}
	}
	if _, ok := w.Concrete.(FormularyItemCreate); ok {
		resourcesMap["FormularyItem"] = addInteraction("FormularyItem", "create")
	}
	if _, ok := w.Concrete.(FormularyItemRead); ok {
		resourcesMap["FormularyItem"] = addInteraction("FormularyItem", "read")
	}
	if _, ok := w.Concrete.(FormularyItemDelete); ok {
		resourcesMap["FormularyItem"] = addInteraction("FormularyItem", "delete")
	}
	if c, ok := w.Concrete.(FormularyItemUpdate); ok {
		r := addInteraction("FormularyItem", "update")
		c, ok := c.(FormularyItemUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesFormularyItem(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["FormularyItem"] = r
	}
	if c, ok := w.Concrete.(FormularyItemSearch); ok {
		c, err := c.SearchCapabilitiesFormularyItem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("FormularyItem", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("FormularyItem-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["FormularyItem"] = r
		}
	}
	if _, ok := w.Concrete.(GenomicStudyCreate); ok {
		resourcesMap["GenomicStudy"] = addInteraction("GenomicStudy", "create")
	}
	if _, ok := w.Concrete.(GenomicStudyRead); ok {
		resourcesMap["GenomicStudy"] = addInteraction("GenomicStudy", "read")
	}
	if _, ok := w.Concrete.(GenomicStudyDelete); ok {
		resourcesMap["GenomicStudy"] = addInteraction("GenomicStudy", "delete")
	}
	if c, ok := w.Concrete.(GenomicStudyUpdate); ok {
		r := addInteraction("GenomicStudy", "update")
		c, ok := c.(GenomicStudyUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesGenomicStudy(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["GenomicStudy"] = r
	}
	if c, ok := w.Concrete.(GenomicStudySearch); ok {
		c, err := c.SearchCapabilitiesGenomicStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("GenomicStudy", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("GenomicStudy-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["GenomicStudy"] = r
		}
	}
	if _, ok := w.Concrete.(GoalCreate); ok {
		resourcesMap["Goal"] = addInteraction("Goal", "create")
	}
	if _, ok := w.Concrete.(GoalRead); ok {
		resourcesMap["Goal"] = addInteraction("Goal", "read")
	}
	if _, ok := w.Concrete.(GoalDelete); ok {
		resourcesMap["Goal"] = addInteraction("Goal", "delete")
	}
	if c, ok := w.Concrete.(GoalUpdate); ok {
		r := addInteraction("Goal", "update")
		c, ok := c.(GoalUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesGoal(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Goal"] = r
	}
	if c, ok := w.Concrete.(GoalSearch); ok {
		c, err := c.SearchCapabilitiesGoal(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Goal", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Goal-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Goal"] = r
		}
	}
	if _, ok := w.Concrete.(GraphDefinitionCreate); ok {
		resourcesMap["GraphDefinition"] = addInteraction("GraphDefinition", "create")
	}
	if _, ok := w.Concrete.(GraphDefinitionRead); ok {
		resourcesMap["GraphDefinition"] = addInteraction("GraphDefinition", "read")
	}
	if _, ok := w.Concrete.(GraphDefinitionDelete); ok {
		resourcesMap["GraphDefinition"] = addInteraction("GraphDefinition", "delete")
	}
	if c, ok := w.Concrete.(GraphDefinitionUpdate); ok {
		r := addInteraction("GraphDefinition", "update")
		c, ok := c.(GraphDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesGraphDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["GraphDefinition"] = r
	}
	if c, ok := w.Concrete.(GraphDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesGraphDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("GraphDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("GraphDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["GraphDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(GroupCreate); ok {
		resourcesMap["Group"] = addInteraction("Group", "create")
	}
	if _, ok := w.Concrete.(GroupRead); ok {
		resourcesMap["Group"] = addInteraction("Group", "read")
	}
	if _, ok := w.Concrete.(GroupDelete); ok {
		resourcesMap["Group"] = addInteraction("Group", "delete")
	}
	if c, ok := w.Concrete.(GroupUpdate); ok {
		r := addInteraction("Group", "update")
		c, ok := c.(GroupUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesGroup(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Group"] = r
	}
	if c, ok := w.Concrete.(GroupSearch); ok {
		c, err := c.SearchCapabilitiesGroup(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Group", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Group-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Group"] = r
		}
	}
	if _, ok := w.Concrete.(GuidanceResponseCreate); ok {
		resourcesMap["GuidanceResponse"] = addInteraction("GuidanceResponse", "create")
	}
	if _, ok := w.Concrete.(GuidanceResponseRead); ok {
		resourcesMap["GuidanceResponse"] = addInteraction("GuidanceResponse", "read")
	}
	if _, ok := w.Concrete.(GuidanceResponseDelete); ok {
		resourcesMap["GuidanceResponse"] = addInteraction("GuidanceResponse", "delete")
	}
	if c, ok := w.Concrete.(GuidanceResponseUpdate); ok {
		r := addInteraction("GuidanceResponse", "update")
		c, ok := c.(GuidanceResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesGuidanceResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["GuidanceResponse"] = r
	}
	if c, ok := w.Concrete.(GuidanceResponseSearch); ok {
		c, err := c.SearchCapabilitiesGuidanceResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("GuidanceResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("GuidanceResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["GuidanceResponse"] = r
		}
	}
	if _, ok := w.Concrete.(HealthcareServiceCreate); ok {
		resourcesMap["HealthcareService"] = addInteraction("HealthcareService", "create")
	}
	if _, ok := w.Concrete.(HealthcareServiceRead); ok {
		resourcesMap["HealthcareService"] = addInteraction("HealthcareService", "read")
	}
	if _, ok := w.Concrete.(HealthcareServiceDelete); ok {
		resourcesMap["HealthcareService"] = addInteraction("HealthcareService", "delete")
	}
	if c, ok := w.Concrete.(HealthcareServiceUpdate); ok {
		r := addInteraction("HealthcareService", "update")
		c, ok := c.(HealthcareServiceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesHealthcareService(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["HealthcareService"] = r
	}
	if c, ok := w.Concrete.(HealthcareServiceSearch); ok {
		c, err := c.SearchCapabilitiesHealthcareService(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("HealthcareService", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("HealthcareService-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["HealthcareService"] = r
		}
	}
	if _, ok := w.Concrete.(ImagingSelectionCreate); ok {
		resourcesMap["ImagingSelection"] = addInteraction("ImagingSelection", "create")
	}
	if _, ok := w.Concrete.(ImagingSelectionRead); ok {
		resourcesMap["ImagingSelection"] = addInteraction("ImagingSelection", "read")
	}
	if _, ok := w.Concrete.(ImagingSelectionDelete); ok {
		resourcesMap["ImagingSelection"] = addInteraction("ImagingSelection", "delete")
	}
	if c, ok := w.Concrete.(ImagingSelectionUpdate); ok {
		r := addInteraction("ImagingSelection", "update")
		c, ok := c.(ImagingSelectionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImagingSelection(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ImagingSelection"] = r
	}
	if c, ok := w.Concrete.(ImagingSelectionSearch); ok {
		c, err := c.SearchCapabilitiesImagingSelection(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ImagingSelection", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ImagingSelection-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ImagingSelection"] = r
		}
	}
	if _, ok := w.Concrete.(ImagingStudyCreate); ok {
		resourcesMap["ImagingStudy"] = addInteraction("ImagingStudy", "create")
	}
	if _, ok := w.Concrete.(ImagingStudyRead); ok {
		resourcesMap["ImagingStudy"] = addInteraction("ImagingStudy", "read")
	}
	if _, ok := w.Concrete.(ImagingStudyDelete); ok {
		resourcesMap["ImagingStudy"] = addInteraction("ImagingStudy", "delete")
	}
	if c, ok := w.Concrete.(ImagingStudyUpdate); ok {
		r := addInteraction("ImagingStudy", "update")
		c, ok := c.(ImagingStudyUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImagingStudy(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ImagingStudy"] = r
	}
	if c, ok := w.Concrete.(ImagingStudySearch); ok {
		c, err := c.SearchCapabilitiesImagingStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ImagingStudy", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ImagingStudy-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ImagingStudy"] = r
		}
	}
	if _, ok := w.Concrete.(ImmunizationCreate); ok {
		resourcesMap["Immunization"] = addInteraction("Immunization", "create")
	}
	if _, ok := w.Concrete.(ImmunizationRead); ok {
		resourcesMap["Immunization"] = addInteraction("Immunization", "read")
	}
	if _, ok := w.Concrete.(ImmunizationDelete); ok {
		resourcesMap["Immunization"] = addInteraction("Immunization", "delete")
	}
	if c, ok := w.Concrete.(ImmunizationUpdate); ok {
		r := addInteraction("Immunization", "update")
		c, ok := c.(ImmunizationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImmunization(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Immunization"] = r
	}
	if c, ok := w.Concrete.(ImmunizationSearch); ok {
		c, err := c.SearchCapabilitiesImmunization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Immunization", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Immunization-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Immunization"] = r
		}
	}
	if _, ok := w.Concrete.(ImmunizationEvaluationCreate); ok {
		resourcesMap["ImmunizationEvaluation"] = addInteraction("ImmunizationEvaluation", "create")
	}
	if _, ok := w.Concrete.(ImmunizationEvaluationRead); ok {
		resourcesMap["ImmunizationEvaluation"] = addInteraction("ImmunizationEvaluation", "read")
	}
	if _, ok := w.Concrete.(ImmunizationEvaluationDelete); ok {
		resourcesMap["ImmunizationEvaluation"] = addInteraction("ImmunizationEvaluation", "delete")
	}
	if c, ok := w.Concrete.(ImmunizationEvaluationUpdate); ok {
		r := addInteraction("ImmunizationEvaluation", "update")
		c, ok := c.(ImmunizationEvaluationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImmunizationEvaluation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ImmunizationEvaluation"] = r
	}
	if c, ok := w.Concrete.(ImmunizationEvaluationSearch); ok {
		c, err := c.SearchCapabilitiesImmunizationEvaluation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ImmunizationEvaluation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ImmunizationEvaluation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ImmunizationEvaluation"] = r
		}
	}
	if _, ok := w.Concrete.(ImmunizationRecommendationCreate); ok {
		resourcesMap["ImmunizationRecommendation"] = addInteraction("ImmunizationRecommendation", "create")
	}
	if _, ok := w.Concrete.(ImmunizationRecommendationRead); ok {
		resourcesMap["ImmunizationRecommendation"] = addInteraction("ImmunizationRecommendation", "read")
	}
	if _, ok := w.Concrete.(ImmunizationRecommendationDelete); ok {
		resourcesMap["ImmunizationRecommendation"] = addInteraction("ImmunizationRecommendation", "delete")
	}
	if c, ok := w.Concrete.(ImmunizationRecommendationUpdate); ok {
		r := addInteraction("ImmunizationRecommendation", "update")
		c, ok := c.(ImmunizationRecommendationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImmunizationRecommendation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ImmunizationRecommendation"] = r
	}
	if c, ok := w.Concrete.(ImmunizationRecommendationSearch); ok {
		c, err := c.SearchCapabilitiesImmunizationRecommendation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ImmunizationRecommendation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ImmunizationRecommendation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ImmunizationRecommendation"] = r
		}
	}
	if _, ok := w.Concrete.(ImplementationGuideCreate); ok {
		resourcesMap["ImplementationGuide"] = addInteraction("ImplementationGuide", "create")
	}
	if _, ok := w.Concrete.(ImplementationGuideRead); ok {
		resourcesMap["ImplementationGuide"] = addInteraction("ImplementationGuide", "read")
	}
	if _, ok := w.Concrete.(ImplementationGuideDelete); ok {
		resourcesMap["ImplementationGuide"] = addInteraction("ImplementationGuide", "delete")
	}
	if c, ok := w.Concrete.(ImplementationGuideUpdate); ok {
		r := addInteraction("ImplementationGuide", "update")
		c, ok := c.(ImplementationGuideUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImplementationGuide(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ImplementationGuide"] = r
	}
	if c, ok := w.Concrete.(ImplementationGuideSearch); ok {
		c, err := c.SearchCapabilitiesImplementationGuide(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ImplementationGuide", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ImplementationGuide-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ImplementationGuide"] = r
		}
	}
	if _, ok := w.Concrete.(IngredientCreate); ok {
		resourcesMap["Ingredient"] = addInteraction("Ingredient", "create")
	}
	if _, ok := w.Concrete.(IngredientRead); ok {
		resourcesMap["Ingredient"] = addInteraction("Ingredient", "read")
	}
	if _, ok := w.Concrete.(IngredientDelete); ok {
		resourcesMap["Ingredient"] = addInteraction("Ingredient", "delete")
	}
	if c, ok := w.Concrete.(IngredientUpdate); ok {
		r := addInteraction("Ingredient", "update")
		c, ok := c.(IngredientUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesIngredient(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Ingredient"] = r
	}
	if c, ok := w.Concrete.(IngredientSearch); ok {
		c, err := c.SearchCapabilitiesIngredient(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Ingredient", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Ingredient-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Ingredient"] = r
		}
	}
	if _, ok := w.Concrete.(InsurancePlanCreate); ok {
		resourcesMap["InsurancePlan"] = addInteraction("InsurancePlan", "create")
	}
	if _, ok := w.Concrete.(InsurancePlanRead); ok {
		resourcesMap["InsurancePlan"] = addInteraction("InsurancePlan", "read")
	}
	if _, ok := w.Concrete.(InsurancePlanDelete); ok {
		resourcesMap["InsurancePlan"] = addInteraction("InsurancePlan", "delete")
	}
	if c, ok := w.Concrete.(InsurancePlanUpdate); ok {
		r := addInteraction("InsurancePlan", "update")
		c, ok := c.(InsurancePlanUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesInsurancePlan(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["InsurancePlan"] = r
	}
	if c, ok := w.Concrete.(InsurancePlanSearch); ok {
		c, err := c.SearchCapabilitiesInsurancePlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("InsurancePlan", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("InsurancePlan-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["InsurancePlan"] = r
		}
	}
	if _, ok := w.Concrete.(InventoryItemCreate); ok {
		resourcesMap["InventoryItem"] = addInteraction("InventoryItem", "create")
	}
	if _, ok := w.Concrete.(InventoryItemRead); ok {
		resourcesMap["InventoryItem"] = addInteraction("InventoryItem", "read")
	}
	if _, ok := w.Concrete.(InventoryItemDelete); ok {
		resourcesMap["InventoryItem"] = addInteraction("InventoryItem", "delete")
	}
	if c, ok := w.Concrete.(InventoryItemUpdate); ok {
		r := addInteraction("InventoryItem", "update")
		c, ok := c.(InventoryItemUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesInventoryItem(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["InventoryItem"] = r
	}
	if c, ok := w.Concrete.(InventoryItemSearch); ok {
		c, err := c.SearchCapabilitiesInventoryItem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("InventoryItem", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("InventoryItem-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["InventoryItem"] = r
		}
	}
	if _, ok := w.Concrete.(InventoryReportCreate); ok {
		resourcesMap["InventoryReport"] = addInteraction("InventoryReport", "create")
	}
	if _, ok := w.Concrete.(InventoryReportRead); ok {
		resourcesMap["InventoryReport"] = addInteraction("InventoryReport", "read")
	}
	if _, ok := w.Concrete.(InventoryReportDelete); ok {
		resourcesMap["InventoryReport"] = addInteraction("InventoryReport", "delete")
	}
	if c, ok := w.Concrete.(InventoryReportUpdate); ok {
		r := addInteraction("InventoryReport", "update")
		c, ok := c.(InventoryReportUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesInventoryReport(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["InventoryReport"] = r
	}
	if c, ok := w.Concrete.(InventoryReportSearch); ok {
		c, err := c.SearchCapabilitiesInventoryReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("InventoryReport", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("InventoryReport-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["InventoryReport"] = r
		}
	}
	if _, ok := w.Concrete.(InvoiceCreate); ok {
		resourcesMap["Invoice"] = addInteraction("Invoice", "create")
	}
	if _, ok := w.Concrete.(InvoiceRead); ok {
		resourcesMap["Invoice"] = addInteraction("Invoice", "read")
	}
	if _, ok := w.Concrete.(InvoiceDelete); ok {
		resourcesMap["Invoice"] = addInteraction("Invoice", "delete")
	}
	if c, ok := w.Concrete.(InvoiceUpdate); ok {
		r := addInteraction("Invoice", "update")
		c, ok := c.(InvoiceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesInvoice(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Invoice"] = r
	}
	if c, ok := w.Concrete.(InvoiceSearch); ok {
		c, err := c.SearchCapabilitiesInvoice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Invoice", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Invoice-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Invoice"] = r
		}
	}
	if _, ok := w.Concrete.(LibraryCreate); ok {
		resourcesMap["Library"] = addInteraction("Library", "create")
	}
	if _, ok := w.Concrete.(LibraryRead); ok {
		resourcesMap["Library"] = addInteraction("Library", "read")
	}
	if _, ok := w.Concrete.(LibraryDelete); ok {
		resourcesMap["Library"] = addInteraction("Library", "delete")
	}
	if c, ok := w.Concrete.(LibraryUpdate); ok {
		r := addInteraction("Library", "update")
		c, ok := c.(LibraryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesLibrary(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Library"] = r
	}
	if c, ok := w.Concrete.(LibrarySearch); ok {
		c, err := c.SearchCapabilitiesLibrary(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Library", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Library-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Library"] = r
		}
	}
	if _, ok := w.Concrete.(LinkageCreate); ok {
		resourcesMap["Linkage"] = addInteraction("Linkage", "create")
	}
	if _, ok := w.Concrete.(LinkageRead); ok {
		resourcesMap["Linkage"] = addInteraction("Linkage", "read")
	}
	if _, ok := w.Concrete.(LinkageDelete); ok {
		resourcesMap["Linkage"] = addInteraction("Linkage", "delete")
	}
	if c, ok := w.Concrete.(LinkageUpdate); ok {
		r := addInteraction("Linkage", "update")
		c, ok := c.(LinkageUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesLinkage(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Linkage"] = r
	}
	if c, ok := w.Concrete.(LinkageSearch); ok {
		c, err := c.SearchCapabilitiesLinkage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Linkage", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Linkage-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Linkage"] = r
		}
	}
	if _, ok := w.Concrete.(ListCreate); ok {
		resourcesMap["List"] = addInteraction("List", "create")
	}
	if _, ok := w.Concrete.(ListRead); ok {
		resourcesMap["List"] = addInteraction("List", "read")
	}
	if _, ok := w.Concrete.(ListDelete); ok {
		resourcesMap["List"] = addInteraction("List", "delete")
	}
	if c, ok := w.Concrete.(ListUpdate); ok {
		r := addInteraction("List", "update")
		c, ok := c.(ListUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesList(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["List"] = r
	}
	if c, ok := w.Concrete.(ListSearch); ok {
		c, err := c.SearchCapabilitiesList(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("List", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("List-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["List"] = r
		}
	}
	if _, ok := w.Concrete.(LocationCreate); ok {
		resourcesMap["Location"] = addInteraction("Location", "create")
	}
	if _, ok := w.Concrete.(LocationRead); ok {
		resourcesMap["Location"] = addInteraction("Location", "read")
	}
	if _, ok := w.Concrete.(LocationDelete); ok {
		resourcesMap["Location"] = addInteraction("Location", "delete")
	}
	if c, ok := w.Concrete.(LocationUpdate); ok {
		r := addInteraction("Location", "update")
		c, ok := c.(LocationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesLocation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Location"] = r
	}
	if c, ok := w.Concrete.(LocationSearch); ok {
		c, err := c.SearchCapabilitiesLocation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Location", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Location-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Location"] = r
		}
	}
	if _, ok := w.Concrete.(ManufacturedItemDefinitionCreate); ok {
		resourcesMap["ManufacturedItemDefinition"] = addInteraction("ManufacturedItemDefinition", "create")
	}
	if _, ok := w.Concrete.(ManufacturedItemDefinitionRead); ok {
		resourcesMap["ManufacturedItemDefinition"] = addInteraction("ManufacturedItemDefinition", "read")
	}
	if _, ok := w.Concrete.(ManufacturedItemDefinitionDelete); ok {
		resourcesMap["ManufacturedItemDefinition"] = addInteraction("ManufacturedItemDefinition", "delete")
	}
	if c, ok := w.Concrete.(ManufacturedItemDefinitionUpdate); ok {
		r := addInteraction("ManufacturedItemDefinition", "update")
		c, ok := c.(ManufacturedItemDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesManufacturedItemDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ManufacturedItemDefinition"] = r
	}
	if c, ok := w.Concrete.(ManufacturedItemDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesManufacturedItemDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ManufacturedItemDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ManufacturedItemDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ManufacturedItemDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(MeasureCreate); ok {
		resourcesMap["Measure"] = addInteraction("Measure", "create")
	}
	if _, ok := w.Concrete.(MeasureRead); ok {
		resourcesMap["Measure"] = addInteraction("Measure", "read")
	}
	if _, ok := w.Concrete.(MeasureDelete); ok {
		resourcesMap["Measure"] = addInteraction("Measure", "delete")
	}
	if c, ok := w.Concrete.(MeasureUpdate); ok {
		r := addInteraction("Measure", "update")
		c, ok := c.(MeasureUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMeasure(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Measure"] = r
	}
	if c, ok := w.Concrete.(MeasureSearch); ok {
		c, err := c.SearchCapabilitiesMeasure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Measure", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Measure-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Measure"] = r
		}
	}
	if _, ok := w.Concrete.(MeasureReportCreate); ok {
		resourcesMap["MeasureReport"] = addInteraction("MeasureReport", "create")
	}
	if _, ok := w.Concrete.(MeasureReportRead); ok {
		resourcesMap["MeasureReport"] = addInteraction("MeasureReport", "read")
	}
	if _, ok := w.Concrete.(MeasureReportDelete); ok {
		resourcesMap["MeasureReport"] = addInteraction("MeasureReport", "delete")
	}
	if c, ok := w.Concrete.(MeasureReportUpdate); ok {
		r := addInteraction("MeasureReport", "update")
		c, ok := c.(MeasureReportUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMeasureReport(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MeasureReport"] = r
	}
	if c, ok := w.Concrete.(MeasureReportSearch); ok {
		c, err := c.SearchCapabilitiesMeasureReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MeasureReport", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MeasureReport-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MeasureReport"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationCreate); ok {
		resourcesMap["Medication"] = addInteraction("Medication", "create")
	}
	if _, ok := w.Concrete.(MedicationRead); ok {
		resourcesMap["Medication"] = addInteraction("Medication", "read")
	}
	if _, ok := w.Concrete.(MedicationDelete); ok {
		resourcesMap["Medication"] = addInteraction("Medication", "delete")
	}
	if c, ok := w.Concrete.(MedicationUpdate); ok {
		r := addInteraction("Medication", "update")
		c, ok := c.(MedicationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedication(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Medication"] = r
	}
	if c, ok := w.Concrete.(MedicationSearch); ok {
		c, err := c.SearchCapabilitiesMedication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Medication", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Medication-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Medication"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationAdministrationCreate); ok {
		resourcesMap["MedicationAdministration"] = addInteraction("MedicationAdministration", "create")
	}
	if _, ok := w.Concrete.(MedicationAdministrationRead); ok {
		resourcesMap["MedicationAdministration"] = addInteraction("MedicationAdministration", "read")
	}
	if _, ok := w.Concrete.(MedicationAdministrationDelete); ok {
		resourcesMap["MedicationAdministration"] = addInteraction("MedicationAdministration", "delete")
	}
	if c, ok := w.Concrete.(MedicationAdministrationUpdate); ok {
		r := addInteraction("MedicationAdministration", "update")
		c, ok := c.(MedicationAdministrationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationAdministration(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationAdministration"] = r
	}
	if c, ok := w.Concrete.(MedicationAdministrationSearch); ok {
		c, err := c.SearchCapabilitiesMedicationAdministration(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationAdministration", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationAdministration-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationAdministration"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationDispenseCreate); ok {
		resourcesMap["MedicationDispense"] = addInteraction("MedicationDispense", "create")
	}
	if _, ok := w.Concrete.(MedicationDispenseRead); ok {
		resourcesMap["MedicationDispense"] = addInteraction("MedicationDispense", "read")
	}
	if _, ok := w.Concrete.(MedicationDispenseDelete); ok {
		resourcesMap["MedicationDispense"] = addInteraction("MedicationDispense", "delete")
	}
	if c, ok := w.Concrete.(MedicationDispenseUpdate); ok {
		r := addInteraction("MedicationDispense", "update")
		c, ok := c.(MedicationDispenseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationDispense(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationDispense"] = r
	}
	if c, ok := w.Concrete.(MedicationDispenseSearch); ok {
		c, err := c.SearchCapabilitiesMedicationDispense(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationDispense", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationDispense-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationDispense"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationKnowledgeCreate); ok {
		resourcesMap["MedicationKnowledge"] = addInteraction("MedicationKnowledge", "create")
	}
	if _, ok := w.Concrete.(MedicationKnowledgeRead); ok {
		resourcesMap["MedicationKnowledge"] = addInteraction("MedicationKnowledge", "read")
	}
	if _, ok := w.Concrete.(MedicationKnowledgeDelete); ok {
		resourcesMap["MedicationKnowledge"] = addInteraction("MedicationKnowledge", "delete")
	}
	if c, ok := w.Concrete.(MedicationKnowledgeUpdate); ok {
		r := addInteraction("MedicationKnowledge", "update")
		c, ok := c.(MedicationKnowledgeUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationKnowledge(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationKnowledge"] = r
	}
	if c, ok := w.Concrete.(MedicationKnowledgeSearch); ok {
		c, err := c.SearchCapabilitiesMedicationKnowledge(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationKnowledge", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationKnowledge-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationKnowledge"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationRequestCreate); ok {
		resourcesMap["MedicationRequest"] = addInteraction("MedicationRequest", "create")
	}
	if _, ok := w.Concrete.(MedicationRequestRead); ok {
		resourcesMap["MedicationRequest"] = addInteraction("MedicationRequest", "read")
	}
	if _, ok := w.Concrete.(MedicationRequestDelete); ok {
		resourcesMap["MedicationRequest"] = addInteraction("MedicationRequest", "delete")
	}
	if c, ok := w.Concrete.(MedicationRequestUpdate); ok {
		r := addInteraction("MedicationRequest", "update")
		c, ok := c.(MedicationRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationRequest"] = r
	}
	if c, ok := w.Concrete.(MedicationRequestSearch); ok {
		c, err := c.SearchCapabilitiesMedicationRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationRequest"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationStatementCreate); ok {
		resourcesMap["MedicationStatement"] = addInteraction("MedicationStatement", "create")
	}
	if _, ok := w.Concrete.(MedicationStatementRead); ok {
		resourcesMap["MedicationStatement"] = addInteraction("MedicationStatement", "read")
	}
	if _, ok := w.Concrete.(MedicationStatementDelete); ok {
		resourcesMap["MedicationStatement"] = addInteraction("MedicationStatement", "delete")
	}
	if c, ok := w.Concrete.(MedicationStatementUpdate); ok {
		r := addInteraction("MedicationStatement", "update")
		c, ok := c.(MedicationStatementUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationStatement(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationStatement"] = r
	}
	if c, ok := w.Concrete.(MedicationStatementSearch); ok {
		c, err := c.SearchCapabilitiesMedicationStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationStatement", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationStatement-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationStatement"] = r
		}
	}
	if _, ok := w.Concrete.(MedicinalProductDefinitionCreate); ok {
		resourcesMap["MedicinalProductDefinition"] = addInteraction("MedicinalProductDefinition", "create")
	}
	if _, ok := w.Concrete.(MedicinalProductDefinitionRead); ok {
		resourcesMap["MedicinalProductDefinition"] = addInteraction("MedicinalProductDefinition", "read")
	}
	if _, ok := w.Concrete.(MedicinalProductDefinitionDelete); ok {
		resourcesMap["MedicinalProductDefinition"] = addInteraction("MedicinalProductDefinition", "delete")
	}
	if c, ok := w.Concrete.(MedicinalProductDefinitionUpdate); ok {
		r := addInteraction("MedicinalProductDefinition", "update")
		c, ok := c.(MedicinalProductDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicinalProductDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicinalProductDefinition"] = r
	}
	if c, ok := w.Concrete.(MedicinalProductDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicinalProductDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicinalProductDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicinalProductDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(MessageDefinitionCreate); ok {
		resourcesMap["MessageDefinition"] = addInteraction("MessageDefinition", "create")
	}
	if _, ok := w.Concrete.(MessageDefinitionRead); ok {
		resourcesMap["MessageDefinition"] = addInteraction("MessageDefinition", "read")
	}
	if _, ok := w.Concrete.(MessageDefinitionDelete); ok {
		resourcesMap["MessageDefinition"] = addInteraction("MessageDefinition", "delete")
	}
	if c, ok := w.Concrete.(MessageDefinitionUpdate); ok {
		r := addInteraction("MessageDefinition", "update")
		c, ok := c.(MessageDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMessageDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MessageDefinition"] = r
	}
	if c, ok := w.Concrete.(MessageDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesMessageDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MessageDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MessageDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MessageDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(MessageHeaderCreate); ok {
		resourcesMap["MessageHeader"] = addInteraction("MessageHeader", "create")
	}
	if _, ok := w.Concrete.(MessageHeaderRead); ok {
		resourcesMap["MessageHeader"] = addInteraction("MessageHeader", "read")
	}
	if _, ok := w.Concrete.(MessageHeaderDelete); ok {
		resourcesMap["MessageHeader"] = addInteraction("MessageHeader", "delete")
	}
	if c, ok := w.Concrete.(MessageHeaderUpdate); ok {
		r := addInteraction("MessageHeader", "update")
		c, ok := c.(MessageHeaderUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMessageHeader(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MessageHeader"] = r
	}
	if c, ok := w.Concrete.(MessageHeaderSearch); ok {
		c, err := c.SearchCapabilitiesMessageHeader(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MessageHeader", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MessageHeader-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MessageHeader"] = r
		}
	}
	if _, ok := w.Concrete.(MolecularSequenceCreate); ok {
		resourcesMap["MolecularSequence"] = addInteraction("MolecularSequence", "create")
	}
	if _, ok := w.Concrete.(MolecularSequenceRead); ok {
		resourcesMap["MolecularSequence"] = addInteraction("MolecularSequence", "read")
	}
	if _, ok := w.Concrete.(MolecularSequenceDelete); ok {
		resourcesMap["MolecularSequence"] = addInteraction("MolecularSequence", "delete")
	}
	if c, ok := w.Concrete.(MolecularSequenceUpdate); ok {
		r := addInteraction("MolecularSequence", "update")
		c, ok := c.(MolecularSequenceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMolecularSequence(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MolecularSequence"] = r
	}
	if c, ok := w.Concrete.(MolecularSequenceSearch); ok {
		c, err := c.SearchCapabilitiesMolecularSequence(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MolecularSequence", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MolecularSequence-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MolecularSequence"] = r
		}
	}
	if _, ok := w.Concrete.(NamingSystemCreate); ok {
		resourcesMap["NamingSystem"] = addInteraction("NamingSystem", "create")
	}
	if _, ok := w.Concrete.(NamingSystemRead); ok {
		resourcesMap["NamingSystem"] = addInteraction("NamingSystem", "read")
	}
	if _, ok := w.Concrete.(NamingSystemDelete); ok {
		resourcesMap["NamingSystem"] = addInteraction("NamingSystem", "delete")
	}
	if c, ok := w.Concrete.(NamingSystemUpdate); ok {
		r := addInteraction("NamingSystem", "update")
		c, ok := c.(NamingSystemUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesNamingSystem(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["NamingSystem"] = r
	}
	if c, ok := w.Concrete.(NamingSystemSearch); ok {
		c, err := c.SearchCapabilitiesNamingSystem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("NamingSystem", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("NamingSystem-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["NamingSystem"] = r
		}
	}
	if _, ok := w.Concrete.(NutritionIntakeCreate); ok {
		resourcesMap["NutritionIntake"] = addInteraction("NutritionIntake", "create")
	}
	if _, ok := w.Concrete.(NutritionIntakeRead); ok {
		resourcesMap["NutritionIntake"] = addInteraction("NutritionIntake", "read")
	}
	if _, ok := w.Concrete.(NutritionIntakeDelete); ok {
		resourcesMap["NutritionIntake"] = addInteraction("NutritionIntake", "delete")
	}
	if c, ok := w.Concrete.(NutritionIntakeUpdate); ok {
		r := addInteraction("NutritionIntake", "update")
		c, ok := c.(NutritionIntakeUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesNutritionIntake(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["NutritionIntake"] = r
	}
	if c, ok := w.Concrete.(NutritionIntakeSearch); ok {
		c, err := c.SearchCapabilitiesNutritionIntake(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("NutritionIntake", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("NutritionIntake-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["NutritionIntake"] = r
		}
	}
	if _, ok := w.Concrete.(NutritionOrderCreate); ok {
		resourcesMap["NutritionOrder"] = addInteraction("NutritionOrder", "create")
	}
	if _, ok := w.Concrete.(NutritionOrderRead); ok {
		resourcesMap["NutritionOrder"] = addInteraction("NutritionOrder", "read")
	}
	if _, ok := w.Concrete.(NutritionOrderDelete); ok {
		resourcesMap["NutritionOrder"] = addInteraction("NutritionOrder", "delete")
	}
	if c, ok := w.Concrete.(NutritionOrderUpdate); ok {
		r := addInteraction("NutritionOrder", "update")
		c, ok := c.(NutritionOrderUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesNutritionOrder(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["NutritionOrder"] = r
	}
	if c, ok := w.Concrete.(NutritionOrderSearch); ok {
		c, err := c.SearchCapabilitiesNutritionOrder(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("NutritionOrder", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("NutritionOrder-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["NutritionOrder"] = r
		}
	}
	if _, ok := w.Concrete.(NutritionProductCreate); ok {
		resourcesMap["NutritionProduct"] = addInteraction("NutritionProduct", "create")
	}
	if _, ok := w.Concrete.(NutritionProductRead); ok {
		resourcesMap["NutritionProduct"] = addInteraction("NutritionProduct", "read")
	}
	if _, ok := w.Concrete.(NutritionProductDelete); ok {
		resourcesMap["NutritionProduct"] = addInteraction("NutritionProduct", "delete")
	}
	if c, ok := w.Concrete.(NutritionProductUpdate); ok {
		r := addInteraction("NutritionProduct", "update")
		c, ok := c.(NutritionProductUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesNutritionProduct(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["NutritionProduct"] = r
	}
	if c, ok := w.Concrete.(NutritionProductSearch); ok {
		c, err := c.SearchCapabilitiesNutritionProduct(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("NutritionProduct", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("NutritionProduct-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["NutritionProduct"] = r
		}
	}
	if _, ok := w.Concrete.(ObservationCreate); ok {
		resourcesMap["Observation"] = addInteraction("Observation", "create")
	}
	if _, ok := w.Concrete.(ObservationRead); ok {
		resourcesMap["Observation"] = addInteraction("Observation", "read")
	}
	if _, ok := w.Concrete.(ObservationDelete); ok {
		resourcesMap["Observation"] = addInteraction("Observation", "delete")
	}
	if c, ok := w.Concrete.(ObservationUpdate); ok {
		r := addInteraction("Observation", "update")
		c, ok := c.(ObservationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesObservation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Observation"] = r
	}
	if c, ok := w.Concrete.(ObservationSearch); ok {
		c, err := c.SearchCapabilitiesObservation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Observation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Observation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Observation"] = r
		}
	}
	if _, ok := w.Concrete.(ObservationDefinitionCreate); ok {
		resourcesMap["ObservationDefinition"] = addInteraction("ObservationDefinition", "create")
	}
	if _, ok := w.Concrete.(ObservationDefinitionRead); ok {
		resourcesMap["ObservationDefinition"] = addInteraction("ObservationDefinition", "read")
	}
	if _, ok := w.Concrete.(ObservationDefinitionDelete); ok {
		resourcesMap["ObservationDefinition"] = addInteraction("ObservationDefinition", "delete")
	}
	if c, ok := w.Concrete.(ObservationDefinitionUpdate); ok {
		r := addInteraction("ObservationDefinition", "update")
		c, ok := c.(ObservationDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesObservationDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ObservationDefinition"] = r
	}
	if c, ok := w.Concrete.(ObservationDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesObservationDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ObservationDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ObservationDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ObservationDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(OperationDefinitionCreate); ok {
		resourcesMap["OperationDefinition"] = addInteraction("OperationDefinition", "create")
	}
	if _, ok := w.Concrete.(OperationDefinitionRead); ok {
		resourcesMap["OperationDefinition"] = addInteraction("OperationDefinition", "read")
	}
	if _, ok := w.Concrete.(OperationDefinitionDelete); ok {
		resourcesMap["OperationDefinition"] = addInteraction("OperationDefinition", "delete")
	}
	if c, ok := w.Concrete.(OperationDefinitionUpdate); ok {
		r := addInteraction("OperationDefinition", "update")
		c, ok := c.(OperationDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesOperationDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["OperationDefinition"] = r
	}
	if c, ok := w.Concrete.(OperationDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesOperationDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("OperationDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("OperationDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["OperationDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(OperationOutcomeCreate); ok {
		resourcesMap["OperationOutcome"] = addInteraction("OperationOutcome", "create")
	}
	if _, ok := w.Concrete.(OperationOutcomeRead); ok {
		resourcesMap["OperationOutcome"] = addInteraction("OperationOutcome", "read")
	}
	if _, ok := w.Concrete.(OperationOutcomeDelete); ok {
		resourcesMap["OperationOutcome"] = addInteraction("OperationOutcome", "delete")
	}
	if c, ok := w.Concrete.(OperationOutcomeUpdate); ok {
		r := addInteraction("OperationOutcome", "update")
		c, ok := c.(OperationOutcomeUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesOperationOutcome(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["OperationOutcome"] = r
	}
	if c, ok := w.Concrete.(OperationOutcomeSearch); ok {
		c, err := c.SearchCapabilitiesOperationOutcome(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("OperationOutcome", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("OperationOutcome-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["OperationOutcome"] = r
		}
	}
	if _, ok := w.Concrete.(OrganizationCreate); ok {
		resourcesMap["Organization"] = addInteraction("Organization", "create")
	}
	if _, ok := w.Concrete.(OrganizationRead); ok {
		resourcesMap["Organization"] = addInteraction("Organization", "read")
	}
	if _, ok := w.Concrete.(OrganizationDelete); ok {
		resourcesMap["Organization"] = addInteraction("Organization", "delete")
	}
	if c, ok := w.Concrete.(OrganizationUpdate); ok {
		r := addInteraction("Organization", "update")
		c, ok := c.(OrganizationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesOrganization(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Organization"] = r
	}
	if c, ok := w.Concrete.(OrganizationSearch); ok {
		c, err := c.SearchCapabilitiesOrganization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Organization", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Organization-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Organization"] = r
		}
	}
	if _, ok := w.Concrete.(OrganizationAffiliationCreate); ok {
		resourcesMap["OrganizationAffiliation"] = addInteraction("OrganizationAffiliation", "create")
	}
	if _, ok := w.Concrete.(OrganizationAffiliationRead); ok {
		resourcesMap["OrganizationAffiliation"] = addInteraction("OrganizationAffiliation", "read")
	}
	if _, ok := w.Concrete.(OrganizationAffiliationDelete); ok {
		resourcesMap["OrganizationAffiliation"] = addInteraction("OrganizationAffiliation", "delete")
	}
	if c, ok := w.Concrete.(OrganizationAffiliationUpdate); ok {
		r := addInteraction("OrganizationAffiliation", "update")
		c, ok := c.(OrganizationAffiliationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesOrganizationAffiliation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["OrganizationAffiliation"] = r
	}
	if c, ok := w.Concrete.(OrganizationAffiliationSearch); ok {
		c, err := c.SearchCapabilitiesOrganizationAffiliation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("OrganizationAffiliation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("OrganizationAffiliation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["OrganizationAffiliation"] = r
		}
	}
	if _, ok := w.Concrete.(PackagedProductDefinitionCreate); ok {
		resourcesMap["PackagedProductDefinition"] = addInteraction("PackagedProductDefinition", "create")
	}
	if _, ok := w.Concrete.(PackagedProductDefinitionRead); ok {
		resourcesMap["PackagedProductDefinition"] = addInteraction("PackagedProductDefinition", "read")
	}
	if _, ok := w.Concrete.(PackagedProductDefinitionDelete); ok {
		resourcesMap["PackagedProductDefinition"] = addInteraction("PackagedProductDefinition", "delete")
	}
	if c, ok := w.Concrete.(PackagedProductDefinitionUpdate); ok {
		r := addInteraction("PackagedProductDefinition", "update")
		c, ok := c.(PackagedProductDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPackagedProductDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PackagedProductDefinition"] = r
	}
	if c, ok := w.Concrete.(PackagedProductDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesPackagedProductDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PackagedProductDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PackagedProductDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PackagedProductDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(ParametersCreate); ok {
		resourcesMap["Parameters"] = addInteraction("Parameters", "create")
	}
	if _, ok := w.Concrete.(ParametersRead); ok {
		resourcesMap["Parameters"] = addInteraction("Parameters", "read")
	}
	if _, ok := w.Concrete.(ParametersDelete); ok {
		resourcesMap["Parameters"] = addInteraction("Parameters", "delete")
	}
	if c, ok := w.Concrete.(ParametersUpdate); ok {
		r := addInteraction("Parameters", "update")
		c, ok := c.(ParametersUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesParameters(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Parameters"] = r
	}
	if c, ok := w.Concrete.(ParametersSearch); ok {
		c, err := c.SearchCapabilitiesParameters(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Parameters", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Parameters-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Parameters"] = r
		}
	}
	if _, ok := w.Concrete.(PatientCreate); ok {
		resourcesMap["Patient"] = addInteraction("Patient", "create")
	}
	if _, ok := w.Concrete.(PatientRead); ok {
		resourcesMap["Patient"] = addInteraction("Patient", "read")
	}
	if _, ok := w.Concrete.(PatientDelete); ok {
		resourcesMap["Patient"] = addInteraction("Patient", "delete")
	}
	if c, ok := w.Concrete.(PatientUpdate); ok {
		r := addInteraction("Patient", "update")
		c, ok := c.(PatientUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPatient(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Patient"] = r
	}
	if c, ok := w.Concrete.(PatientSearch); ok {
		c, err := c.SearchCapabilitiesPatient(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Patient", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Patient-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Patient"] = r
		}
	}
	if _, ok := w.Concrete.(PaymentNoticeCreate); ok {
		resourcesMap["PaymentNotice"] = addInteraction("PaymentNotice", "create")
	}
	if _, ok := w.Concrete.(PaymentNoticeRead); ok {
		resourcesMap["PaymentNotice"] = addInteraction("PaymentNotice", "read")
	}
	if _, ok := w.Concrete.(PaymentNoticeDelete); ok {
		resourcesMap["PaymentNotice"] = addInteraction("PaymentNotice", "delete")
	}
	if c, ok := w.Concrete.(PaymentNoticeUpdate); ok {
		r := addInteraction("PaymentNotice", "update")
		c, ok := c.(PaymentNoticeUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPaymentNotice(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PaymentNotice"] = r
	}
	if c, ok := w.Concrete.(PaymentNoticeSearch); ok {
		c, err := c.SearchCapabilitiesPaymentNotice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PaymentNotice", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PaymentNotice-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PaymentNotice"] = r
		}
	}
	if _, ok := w.Concrete.(PaymentReconciliationCreate); ok {
		resourcesMap["PaymentReconciliation"] = addInteraction("PaymentReconciliation", "create")
	}
	if _, ok := w.Concrete.(PaymentReconciliationRead); ok {
		resourcesMap["PaymentReconciliation"] = addInteraction("PaymentReconciliation", "read")
	}
	if _, ok := w.Concrete.(PaymentReconciliationDelete); ok {
		resourcesMap["PaymentReconciliation"] = addInteraction("PaymentReconciliation", "delete")
	}
	if c, ok := w.Concrete.(PaymentReconciliationUpdate); ok {
		r := addInteraction("PaymentReconciliation", "update")
		c, ok := c.(PaymentReconciliationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPaymentReconciliation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PaymentReconciliation"] = r
	}
	if c, ok := w.Concrete.(PaymentReconciliationSearch); ok {
		c, err := c.SearchCapabilitiesPaymentReconciliation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PaymentReconciliation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PaymentReconciliation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PaymentReconciliation"] = r
		}
	}
	if _, ok := w.Concrete.(PermissionCreate); ok {
		resourcesMap["Permission"] = addInteraction("Permission", "create")
	}
	if _, ok := w.Concrete.(PermissionRead); ok {
		resourcesMap["Permission"] = addInteraction("Permission", "read")
	}
	if _, ok := w.Concrete.(PermissionDelete); ok {
		resourcesMap["Permission"] = addInteraction("Permission", "delete")
	}
	if c, ok := w.Concrete.(PermissionUpdate); ok {
		r := addInteraction("Permission", "update")
		c, ok := c.(PermissionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPermission(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Permission"] = r
	}
	if c, ok := w.Concrete.(PermissionSearch); ok {
		c, err := c.SearchCapabilitiesPermission(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Permission", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Permission-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Permission"] = r
		}
	}
	if _, ok := w.Concrete.(PersonCreate); ok {
		resourcesMap["Person"] = addInteraction("Person", "create")
	}
	if _, ok := w.Concrete.(PersonRead); ok {
		resourcesMap["Person"] = addInteraction("Person", "read")
	}
	if _, ok := w.Concrete.(PersonDelete); ok {
		resourcesMap["Person"] = addInteraction("Person", "delete")
	}
	if c, ok := w.Concrete.(PersonUpdate); ok {
		r := addInteraction("Person", "update")
		c, ok := c.(PersonUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPerson(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Person"] = r
	}
	if c, ok := w.Concrete.(PersonSearch); ok {
		c, err := c.SearchCapabilitiesPerson(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Person", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Person-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Person"] = r
		}
	}
	if _, ok := w.Concrete.(PlanDefinitionCreate); ok {
		resourcesMap["PlanDefinition"] = addInteraction("PlanDefinition", "create")
	}
	if _, ok := w.Concrete.(PlanDefinitionRead); ok {
		resourcesMap["PlanDefinition"] = addInteraction("PlanDefinition", "read")
	}
	if _, ok := w.Concrete.(PlanDefinitionDelete); ok {
		resourcesMap["PlanDefinition"] = addInteraction("PlanDefinition", "delete")
	}
	if c, ok := w.Concrete.(PlanDefinitionUpdate); ok {
		r := addInteraction("PlanDefinition", "update")
		c, ok := c.(PlanDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPlanDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PlanDefinition"] = r
	}
	if c, ok := w.Concrete.(PlanDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesPlanDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PlanDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PlanDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PlanDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(PractitionerCreate); ok {
		resourcesMap["Practitioner"] = addInteraction("Practitioner", "create")
	}
	if _, ok := w.Concrete.(PractitionerRead); ok {
		resourcesMap["Practitioner"] = addInteraction("Practitioner", "read")
	}
	if _, ok := w.Concrete.(PractitionerDelete); ok {
		resourcesMap["Practitioner"] = addInteraction("Practitioner", "delete")
	}
	if c, ok := w.Concrete.(PractitionerUpdate); ok {
		r := addInteraction("Practitioner", "update")
		c, ok := c.(PractitionerUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPractitioner(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Practitioner"] = r
	}
	if c, ok := w.Concrete.(PractitionerSearch); ok {
		c, err := c.SearchCapabilitiesPractitioner(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Practitioner", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Practitioner-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Practitioner"] = r
		}
	}
	if _, ok := w.Concrete.(PractitionerRoleCreate); ok {
		resourcesMap["PractitionerRole"] = addInteraction("PractitionerRole", "create")
	}
	if _, ok := w.Concrete.(PractitionerRoleRead); ok {
		resourcesMap["PractitionerRole"] = addInteraction("PractitionerRole", "read")
	}
	if _, ok := w.Concrete.(PractitionerRoleDelete); ok {
		resourcesMap["PractitionerRole"] = addInteraction("PractitionerRole", "delete")
	}
	if c, ok := w.Concrete.(PractitionerRoleUpdate); ok {
		r := addInteraction("PractitionerRole", "update")
		c, ok := c.(PractitionerRoleUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPractitionerRole(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PractitionerRole"] = r
	}
	if c, ok := w.Concrete.(PractitionerRoleSearch); ok {
		c, err := c.SearchCapabilitiesPractitionerRole(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PractitionerRole", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PractitionerRole-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PractitionerRole"] = r
		}
	}
	if _, ok := w.Concrete.(ProcedureCreate); ok {
		resourcesMap["Procedure"] = addInteraction("Procedure", "create")
	}
	if _, ok := w.Concrete.(ProcedureRead); ok {
		resourcesMap["Procedure"] = addInteraction("Procedure", "read")
	}
	if _, ok := w.Concrete.(ProcedureDelete); ok {
		resourcesMap["Procedure"] = addInteraction("Procedure", "delete")
	}
	if c, ok := w.Concrete.(ProcedureUpdate); ok {
		r := addInteraction("Procedure", "update")
		c, ok := c.(ProcedureUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesProcedure(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Procedure"] = r
	}
	if c, ok := w.Concrete.(ProcedureSearch); ok {
		c, err := c.SearchCapabilitiesProcedure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Procedure", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Procedure-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Procedure"] = r
		}
	}
	if _, ok := w.Concrete.(ProvenanceCreate); ok {
		resourcesMap["Provenance"] = addInteraction("Provenance", "create")
	}
	if _, ok := w.Concrete.(ProvenanceRead); ok {
		resourcesMap["Provenance"] = addInteraction("Provenance", "read")
	}
	if _, ok := w.Concrete.(ProvenanceDelete); ok {
		resourcesMap["Provenance"] = addInteraction("Provenance", "delete")
	}
	if c, ok := w.Concrete.(ProvenanceUpdate); ok {
		r := addInteraction("Provenance", "update")
		c, ok := c.(ProvenanceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesProvenance(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Provenance"] = r
	}
	if c, ok := w.Concrete.(ProvenanceSearch); ok {
		c, err := c.SearchCapabilitiesProvenance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Provenance", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Provenance-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Provenance"] = r
		}
	}
	if _, ok := w.Concrete.(QuestionnaireCreate); ok {
		resourcesMap["Questionnaire"] = addInteraction("Questionnaire", "create")
	}
	if _, ok := w.Concrete.(QuestionnaireRead); ok {
		resourcesMap["Questionnaire"] = addInteraction("Questionnaire", "read")
	}
	if _, ok := w.Concrete.(QuestionnaireDelete); ok {
		resourcesMap["Questionnaire"] = addInteraction("Questionnaire", "delete")
	}
	if c, ok := w.Concrete.(QuestionnaireUpdate); ok {
		r := addInteraction("Questionnaire", "update")
		c, ok := c.(QuestionnaireUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesQuestionnaire(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Questionnaire"] = r
	}
	if c, ok := w.Concrete.(QuestionnaireSearch); ok {
		c, err := c.SearchCapabilitiesQuestionnaire(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Questionnaire", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Questionnaire-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Questionnaire"] = r
		}
	}
	if _, ok := w.Concrete.(QuestionnaireResponseCreate); ok {
		resourcesMap["QuestionnaireResponse"] = addInteraction("QuestionnaireResponse", "create")
	}
	if _, ok := w.Concrete.(QuestionnaireResponseRead); ok {
		resourcesMap["QuestionnaireResponse"] = addInteraction("QuestionnaireResponse", "read")
	}
	if _, ok := w.Concrete.(QuestionnaireResponseDelete); ok {
		resourcesMap["QuestionnaireResponse"] = addInteraction("QuestionnaireResponse", "delete")
	}
	if c, ok := w.Concrete.(QuestionnaireResponseUpdate); ok {
		r := addInteraction("QuestionnaireResponse", "update")
		c, ok := c.(QuestionnaireResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesQuestionnaireResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["QuestionnaireResponse"] = r
	}
	if c, ok := w.Concrete.(QuestionnaireResponseSearch); ok {
		c, err := c.SearchCapabilitiesQuestionnaireResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("QuestionnaireResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("QuestionnaireResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["QuestionnaireResponse"] = r
		}
	}
	if _, ok := w.Concrete.(RegulatedAuthorizationCreate); ok {
		resourcesMap["RegulatedAuthorization"] = addInteraction("RegulatedAuthorization", "create")
	}
	if _, ok := w.Concrete.(RegulatedAuthorizationRead); ok {
		resourcesMap["RegulatedAuthorization"] = addInteraction("RegulatedAuthorization", "read")
	}
	if _, ok := w.Concrete.(RegulatedAuthorizationDelete); ok {
		resourcesMap["RegulatedAuthorization"] = addInteraction("RegulatedAuthorization", "delete")
	}
	if c, ok := w.Concrete.(RegulatedAuthorizationUpdate); ok {
		r := addInteraction("RegulatedAuthorization", "update")
		c, ok := c.(RegulatedAuthorizationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesRegulatedAuthorization(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["RegulatedAuthorization"] = r
	}
	if c, ok := w.Concrete.(RegulatedAuthorizationSearch); ok {
		c, err := c.SearchCapabilitiesRegulatedAuthorization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("RegulatedAuthorization", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("RegulatedAuthorization-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["RegulatedAuthorization"] = r
		}
	}
	if _, ok := w.Concrete.(RelatedPersonCreate); ok {
		resourcesMap["RelatedPerson"] = addInteraction("RelatedPerson", "create")
	}
	if _, ok := w.Concrete.(RelatedPersonRead); ok {
		resourcesMap["RelatedPerson"] = addInteraction("RelatedPerson", "read")
	}
	if _, ok := w.Concrete.(RelatedPersonDelete); ok {
		resourcesMap["RelatedPerson"] = addInteraction("RelatedPerson", "delete")
	}
	if c, ok := w.Concrete.(RelatedPersonUpdate); ok {
		r := addInteraction("RelatedPerson", "update")
		c, ok := c.(RelatedPersonUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesRelatedPerson(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["RelatedPerson"] = r
	}
	if c, ok := w.Concrete.(RelatedPersonSearch); ok {
		c, err := c.SearchCapabilitiesRelatedPerson(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("RelatedPerson", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("RelatedPerson-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["RelatedPerson"] = r
		}
	}
	if _, ok := w.Concrete.(RequestOrchestrationCreate); ok {
		resourcesMap["RequestOrchestration"] = addInteraction("RequestOrchestration", "create")
	}
	if _, ok := w.Concrete.(RequestOrchestrationRead); ok {
		resourcesMap["RequestOrchestration"] = addInteraction("RequestOrchestration", "read")
	}
	if _, ok := w.Concrete.(RequestOrchestrationDelete); ok {
		resourcesMap["RequestOrchestration"] = addInteraction("RequestOrchestration", "delete")
	}
	if c, ok := w.Concrete.(RequestOrchestrationUpdate); ok {
		r := addInteraction("RequestOrchestration", "update")
		c, ok := c.(RequestOrchestrationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesRequestOrchestration(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["RequestOrchestration"] = r
	}
	if c, ok := w.Concrete.(RequestOrchestrationSearch); ok {
		c, err := c.SearchCapabilitiesRequestOrchestration(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("RequestOrchestration", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("RequestOrchestration-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["RequestOrchestration"] = r
		}
	}
	if _, ok := w.Concrete.(RequirementsCreate); ok {
		resourcesMap["Requirements"] = addInteraction("Requirements", "create")
	}
	if _, ok := w.Concrete.(RequirementsRead); ok {
		resourcesMap["Requirements"] = addInteraction("Requirements", "read")
	}
	if _, ok := w.Concrete.(RequirementsDelete); ok {
		resourcesMap["Requirements"] = addInteraction("Requirements", "delete")
	}
	if c, ok := w.Concrete.(RequirementsUpdate); ok {
		r := addInteraction("Requirements", "update")
		c, ok := c.(RequirementsUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesRequirements(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Requirements"] = r
	}
	if c, ok := w.Concrete.(RequirementsSearch); ok {
		c, err := c.SearchCapabilitiesRequirements(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Requirements", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Requirements-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Requirements"] = r
		}
	}
	if _, ok := w.Concrete.(ResearchStudyCreate); ok {
		resourcesMap["ResearchStudy"] = addInteraction("ResearchStudy", "create")
	}
	if _, ok := w.Concrete.(ResearchStudyRead); ok {
		resourcesMap["ResearchStudy"] = addInteraction("ResearchStudy", "read")
	}
	if _, ok := w.Concrete.(ResearchStudyDelete); ok {
		resourcesMap["ResearchStudy"] = addInteraction("ResearchStudy", "delete")
	}
	if c, ok := w.Concrete.(ResearchStudyUpdate); ok {
		r := addInteraction("ResearchStudy", "update")
		c, ok := c.(ResearchStudyUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesResearchStudy(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ResearchStudy"] = r
	}
	if c, ok := w.Concrete.(ResearchStudySearch); ok {
		c, err := c.SearchCapabilitiesResearchStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ResearchStudy", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ResearchStudy-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ResearchStudy"] = r
		}
	}
	if _, ok := w.Concrete.(ResearchSubjectCreate); ok {
		resourcesMap["ResearchSubject"] = addInteraction("ResearchSubject", "create")
	}
	if _, ok := w.Concrete.(ResearchSubjectRead); ok {
		resourcesMap["ResearchSubject"] = addInteraction("ResearchSubject", "read")
	}
	if _, ok := w.Concrete.(ResearchSubjectDelete); ok {
		resourcesMap["ResearchSubject"] = addInteraction("ResearchSubject", "delete")
	}
	if c, ok := w.Concrete.(ResearchSubjectUpdate); ok {
		r := addInteraction("ResearchSubject", "update")
		c, ok := c.(ResearchSubjectUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesResearchSubject(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ResearchSubject"] = r
	}
	if c, ok := w.Concrete.(ResearchSubjectSearch); ok {
		c, err := c.SearchCapabilitiesResearchSubject(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ResearchSubject", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ResearchSubject-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ResearchSubject"] = r
		}
	}
	if _, ok := w.Concrete.(RiskAssessmentCreate); ok {
		resourcesMap["RiskAssessment"] = addInteraction("RiskAssessment", "create")
	}
	if _, ok := w.Concrete.(RiskAssessmentRead); ok {
		resourcesMap["RiskAssessment"] = addInteraction("RiskAssessment", "read")
	}
	if _, ok := w.Concrete.(RiskAssessmentDelete); ok {
		resourcesMap["RiskAssessment"] = addInteraction("RiskAssessment", "delete")
	}
	if c, ok := w.Concrete.(RiskAssessmentUpdate); ok {
		r := addInteraction("RiskAssessment", "update")
		c, ok := c.(RiskAssessmentUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesRiskAssessment(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["RiskAssessment"] = r
	}
	if c, ok := w.Concrete.(RiskAssessmentSearch); ok {
		c, err := c.SearchCapabilitiesRiskAssessment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("RiskAssessment", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("RiskAssessment-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["RiskAssessment"] = r
		}
	}
	if _, ok := w.Concrete.(ScheduleCreate); ok {
		resourcesMap["Schedule"] = addInteraction("Schedule", "create")
	}
	if _, ok := w.Concrete.(ScheduleRead); ok {
		resourcesMap["Schedule"] = addInteraction("Schedule", "read")
	}
	if _, ok := w.Concrete.(ScheduleDelete); ok {
		resourcesMap["Schedule"] = addInteraction("Schedule", "delete")
	}
	if c, ok := w.Concrete.(ScheduleUpdate); ok {
		r := addInteraction("Schedule", "update")
		c, ok := c.(ScheduleUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSchedule(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Schedule"] = r
	}
	if c, ok := w.Concrete.(ScheduleSearch); ok {
		c, err := c.SearchCapabilitiesSchedule(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Schedule", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Schedule-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Schedule"] = r
		}
	}
	if _, ok := w.Concrete.(SearchParameterCreate); ok {
		resourcesMap["SearchParameter"] = addInteraction("SearchParameter", "create")
	}
	if _, ok := w.Concrete.(SearchParameterRead); ok {
		resourcesMap["SearchParameter"] = addInteraction("SearchParameter", "read")
	}
	if _, ok := w.Concrete.(SearchParameterDelete); ok {
		resourcesMap["SearchParameter"] = addInteraction("SearchParameter", "delete")
	}
	if c, ok := w.Concrete.(SearchParameterUpdate); ok {
		r := addInteraction("SearchParameter", "update")
		c, ok := c.(SearchParameterUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSearchParameter(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SearchParameter"] = r
	}
	if c, ok := w.Concrete.(SearchParameterSearch); ok {
		c, err := c.SearchCapabilitiesSearchParameter(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SearchParameter", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SearchParameter-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SearchParameter"] = r
		}
	}
	if _, ok := w.Concrete.(ServiceRequestCreate); ok {
		resourcesMap["ServiceRequest"] = addInteraction("ServiceRequest", "create")
	}
	if _, ok := w.Concrete.(ServiceRequestRead); ok {
		resourcesMap["ServiceRequest"] = addInteraction("ServiceRequest", "read")
	}
	if _, ok := w.Concrete.(ServiceRequestDelete); ok {
		resourcesMap["ServiceRequest"] = addInteraction("ServiceRequest", "delete")
	}
	if c, ok := w.Concrete.(ServiceRequestUpdate); ok {
		r := addInteraction("ServiceRequest", "update")
		c, ok := c.(ServiceRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesServiceRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ServiceRequest"] = r
	}
	if c, ok := w.Concrete.(ServiceRequestSearch); ok {
		c, err := c.SearchCapabilitiesServiceRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ServiceRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ServiceRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ServiceRequest"] = r
		}
	}
	if _, ok := w.Concrete.(SlotCreate); ok {
		resourcesMap["Slot"] = addInteraction("Slot", "create")
	}
	if _, ok := w.Concrete.(SlotRead); ok {
		resourcesMap["Slot"] = addInteraction("Slot", "read")
	}
	if _, ok := w.Concrete.(SlotDelete); ok {
		resourcesMap["Slot"] = addInteraction("Slot", "delete")
	}
	if c, ok := w.Concrete.(SlotUpdate); ok {
		r := addInteraction("Slot", "update")
		c, ok := c.(SlotUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSlot(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Slot"] = r
	}
	if c, ok := w.Concrete.(SlotSearch); ok {
		c, err := c.SearchCapabilitiesSlot(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Slot", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Slot-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Slot"] = r
		}
	}
	if _, ok := w.Concrete.(SpecimenCreate); ok {
		resourcesMap["Specimen"] = addInteraction("Specimen", "create")
	}
	if _, ok := w.Concrete.(SpecimenRead); ok {
		resourcesMap["Specimen"] = addInteraction("Specimen", "read")
	}
	if _, ok := w.Concrete.(SpecimenDelete); ok {
		resourcesMap["Specimen"] = addInteraction("Specimen", "delete")
	}
	if c, ok := w.Concrete.(SpecimenUpdate); ok {
		r := addInteraction("Specimen", "update")
		c, ok := c.(SpecimenUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSpecimen(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Specimen"] = r
	}
	if c, ok := w.Concrete.(SpecimenSearch); ok {
		c, err := c.SearchCapabilitiesSpecimen(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Specimen", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Specimen-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Specimen"] = r
		}
	}
	if _, ok := w.Concrete.(SpecimenDefinitionCreate); ok {
		resourcesMap["SpecimenDefinition"] = addInteraction("SpecimenDefinition", "create")
	}
	if _, ok := w.Concrete.(SpecimenDefinitionRead); ok {
		resourcesMap["SpecimenDefinition"] = addInteraction("SpecimenDefinition", "read")
	}
	if _, ok := w.Concrete.(SpecimenDefinitionDelete); ok {
		resourcesMap["SpecimenDefinition"] = addInteraction("SpecimenDefinition", "delete")
	}
	if c, ok := w.Concrete.(SpecimenDefinitionUpdate); ok {
		r := addInteraction("SpecimenDefinition", "update")
		c, ok := c.(SpecimenDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSpecimenDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SpecimenDefinition"] = r
	}
	if c, ok := w.Concrete.(SpecimenDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesSpecimenDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SpecimenDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SpecimenDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SpecimenDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(StructureDefinitionCreate); ok {
		resourcesMap["StructureDefinition"] = addInteraction("StructureDefinition", "create")
	}
	if _, ok := w.Concrete.(StructureDefinitionRead); ok {
		resourcesMap["StructureDefinition"] = addInteraction("StructureDefinition", "read")
	}
	if _, ok := w.Concrete.(StructureDefinitionDelete); ok {
		resourcesMap["StructureDefinition"] = addInteraction("StructureDefinition", "delete")
	}
	if c, ok := w.Concrete.(StructureDefinitionUpdate); ok {
		r := addInteraction("StructureDefinition", "update")
		c, ok := c.(StructureDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesStructureDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["StructureDefinition"] = r
	}
	if c, ok := w.Concrete.(StructureDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesStructureDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("StructureDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("StructureDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["StructureDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(StructureMapCreate); ok {
		resourcesMap["StructureMap"] = addInteraction("StructureMap", "create")
	}
	if _, ok := w.Concrete.(StructureMapRead); ok {
		resourcesMap["StructureMap"] = addInteraction("StructureMap", "read")
	}
	if _, ok := w.Concrete.(StructureMapDelete); ok {
		resourcesMap["StructureMap"] = addInteraction("StructureMap", "delete")
	}
	if c, ok := w.Concrete.(StructureMapUpdate); ok {
		r := addInteraction("StructureMap", "update")
		c, ok := c.(StructureMapUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesStructureMap(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["StructureMap"] = r
	}
	if c, ok := w.Concrete.(StructureMapSearch); ok {
		c, err := c.SearchCapabilitiesStructureMap(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("StructureMap", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("StructureMap-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["StructureMap"] = r
		}
	}
	if _, ok := w.Concrete.(SubscriptionCreate); ok {
		resourcesMap["Subscription"] = addInteraction("Subscription", "create")
	}
	if _, ok := w.Concrete.(SubscriptionRead); ok {
		resourcesMap["Subscription"] = addInteraction("Subscription", "read")
	}
	if _, ok := w.Concrete.(SubscriptionDelete); ok {
		resourcesMap["Subscription"] = addInteraction("Subscription", "delete")
	}
	if c, ok := w.Concrete.(SubscriptionUpdate); ok {
		r := addInteraction("Subscription", "update")
		c, ok := c.(SubscriptionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubscription(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Subscription"] = r
	}
	if c, ok := w.Concrete.(SubscriptionSearch); ok {
		c, err := c.SearchCapabilitiesSubscription(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Subscription", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Subscription-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Subscription"] = r
		}
	}
	if _, ok := w.Concrete.(SubscriptionStatusCreate); ok {
		resourcesMap["SubscriptionStatus"] = addInteraction("SubscriptionStatus", "create")
	}
	if _, ok := w.Concrete.(SubscriptionStatusRead); ok {
		resourcesMap["SubscriptionStatus"] = addInteraction("SubscriptionStatus", "read")
	}
	if _, ok := w.Concrete.(SubscriptionStatusDelete); ok {
		resourcesMap["SubscriptionStatus"] = addInteraction("SubscriptionStatus", "delete")
	}
	if c, ok := w.Concrete.(SubscriptionStatusUpdate); ok {
		r := addInteraction("SubscriptionStatus", "update")
		c, ok := c.(SubscriptionStatusUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubscriptionStatus(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubscriptionStatus"] = r
	}
	if c, ok := w.Concrete.(SubscriptionStatusSearch); ok {
		c, err := c.SearchCapabilitiesSubscriptionStatus(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubscriptionStatus", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubscriptionStatus-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubscriptionStatus"] = r
		}
	}
	if _, ok := w.Concrete.(SubscriptionTopicCreate); ok {
		resourcesMap["SubscriptionTopic"] = addInteraction("SubscriptionTopic", "create")
	}
	if _, ok := w.Concrete.(SubscriptionTopicRead); ok {
		resourcesMap["SubscriptionTopic"] = addInteraction("SubscriptionTopic", "read")
	}
	if _, ok := w.Concrete.(SubscriptionTopicDelete); ok {
		resourcesMap["SubscriptionTopic"] = addInteraction("SubscriptionTopic", "delete")
	}
	if c, ok := w.Concrete.(SubscriptionTopicUpdate); ok {
		r := addInteraction("SubscriptionTopic", "update")
		c, ok := c.(SubscriptionTopicUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubscriptionTopic(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubscriptionTopic"] = r
	}
	if c, ok := w.Concrete.(SubscriptionTopicSearch); ok {
		c, err := c.SearchCapabilitiesSubscriptionTopic(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubscriptionTopic", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubscriptionTopic-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubscriptionTopic"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceCreate); ok {
		resourcesMap["Substance"] = addInteraction("Substance", "create")
	}
	if _, ok := w.Concrete.(SubstanceRead); ok {
		resourcesMap["Substance"] = addInteraction("Substance", "read")
	}
	if _, ok := w.Concrete.(SubstanceDelete); ok {
		resourcesMap["Substance"] = addInteraction("Substance", "delete")
	}
	if c, ok := w.Concrete.(SubstanceUpdate); ok {
		r := addInteraction("Substance", "update")
		c, ok := c.(SubstanceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstance(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Substance"] = r
	}
	if c, ok := w.Concrete.(SubstanceSearch); ok {
		c, err := c.SearchCapabilitiesSubstance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Substance", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Substance-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Substance"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceDefinitionCreate); ok {
		resourcesMap["SubstanceDefinition"] = addInteraction("SubstanceDefinition", "create")
	}
	if _, ok := w.Concrete.(SubstanceDefinitionRead); ok {
		resourcesMap["SubstanceDefinition"] = addInteraction("SubstanceDefinition", "read")
	}
	if _, ok := w.Concrete.(SubstanceDefinitionDelete); ok {
		resourcesMap["SubstanceDefinition"] = addInteraction("SubstanceDefinition", "delete")
	}
	if c, ok := w.Concrete.(SubstanceDefinitionUpdate); ok {
		r := addInteraction("SubstanceDefinition", "update")
		c, ok := c.(SubstanceDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstanceDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubstanceDefinition"] = r
	}
	if c, ok := w.Concrete.(SubstanceDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubstanceDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubstanceDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubstanceDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceNucleicAcidCreate); ok {
		resourcesMap["SubstanceNucleicAcid"] = addInteraction("SubstanceNucleicAcid", "create")
	}
	if _, ok := w.Concrete.(SubstanceNucleicAcidRead); ok {
		resourcesMap["SubstanceNucleicAcid"] = addInteraction("SubstanceNucleicAcid", "read")
	}
	if _, ok := w.Concrete.(SubstanceNucleicAcidDelete); ok {
		resourcesMap["SubstanceNucleicAcid"] = addInteraction("SubstanceNucleicAcid", "delete")
	}
	if c, ok := w.Concrete.(SubstanceNucleicAcidUpdate); ok {
		r := addInteraction("SubstanceNucleicAcid", "update")
		c, ok := c.(SubstanceNucleicAcidUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstanceNucleicAcid(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubstanceNucleicAcid"] = r
	}
	if c, ok := w.Concrete.(SubstanceNucleicAcidSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceNucleicAcid(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubstanceNucleicAcid", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubstanceNucleicAcid-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubstanceNucleicAcid"] = r
		}
	}
	if _, ok := w.Concrete.(SubstancePolymerCreate); ok {
		resourcesMap["SubstancePolymer"] = addInteraction("SubstancePolymer", "create")
	}
	if _, ok := w.Concrete.(SubstancePolymerRead); ok {
		resourcesMap["SubstancePolymer"] = addInteraction("SubstancePolymer", "read")
	}
	if _, ok := w.Concrete.(SubstancePolymerDelete); ok {
		resourcesMap["SubstancePolymer"] = addInteraction("SubstancePolymer", "delete")
	}
	if c, ok := w.Concrete.(SubstancePolymerUpdate); ok {
		r := addInteraction("SubstancePolymer", "update")
		c, ok := c.(SubstancePolymerUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstancePolymer(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubstancePolymer"] = r
	}
	if c, ok := w.Concrete.(SubstancePolymerSearch); ok {
		c, err := c.SearchCapabilitiesSubstancePolymer(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubstancePolymer", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubstancePolymer-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubstancePolymer"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceProteinCreate); ok {
		resourcesMap["SubstanceProtein"] = addInteraction("SubstanceProtein", "create")
	}
	if _, ok := w.Concrete.(SubstanceProteinRead); ok {
		resourcesMap["SubstanceProtein"] = addInteraction("SubstanceProtein", "read")
	}
	if _, ok := w.Concrete.(SubstanceProteinDelete); ok {
		resourcesMap["SubstanceProtein"] = addInteraction("SubstanceProtein", "delete")
	}
	if c, ok := w.Concrete.(SubstanceProteinUpdate); ok {
		r := addInteraction("SubstanceProtein", "update")
		c, ok := c.(SubstanceProteinUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstanceProtein(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubstanceProtein"] = r
	}
	if c, ok := w.Concrete.(SubstanceProteinSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceProtein(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubstanceProtein", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubstanceProtein-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubstanceProtein"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceReferenceInformationCreate); ok {
		resourcesMap["SubstanceReferenceInformation"] = addInteraction("SubstanceReferenceInformation", "create")
	}
	if _, ok := w.Concrete.(SubstanceReferenceInformationRead); ok {
		resourcesMap["SubstanceReferenceInformation"] = addInteraction("SubstanceReferenceInformation", "read")
	}
	if _, ok := w.Concrete.(SubstanceReferenceInformationDelete); ok {
		resourcesMap["SubstanceReferenceInformation"] = addInteraction("SubstanceReferenceInformation", "delete")
	}
	if c, ok := w.Concrete.(SubstanceReferenceInformationUpdate); ok {
		r := addInteraction("SubstanceReferenceInformation", "update")
		c, ok := c.(SubstanceReferenceInformationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstanceReferenceInformation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubstanceReferenceInformation"] = r
	}
	if c, ok := w.Concrete.(SubstanceReferenceInformationSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceReferenceInformation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubstanceReferenceInformation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubstanceReferenceInformation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubstanceReferenceInformation"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceSourceMaterialCreate); ok {
		resourcesMap["SubstanceSourceMaterial"] = addInteraction("SubstanceSourceMaterial", "create")
	}
	if _, ok := w.Concrete.(SubstanceSourceMaterialRead); ok {
		resourcesMap["SubstanceSourceMaterial"] = addInteraction("SubstanceSourceMaterial", "read")
	}
	if _, ok := w.Concrete.(SubstanceSourceMaterialDelete); ok {
		resourcesMap["SubstanceSourceMaterial"] = addInteraction("SubstanceSourceMaterial", "delete")
	}
	if c, ok := w.Concrete.(SubstanceSourceMaterialUpdate); ok {
		r := addInteraction("SubstanceSourceMaterial", "update")
		c, ok := c.(SubstanceSourceMaterialUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstanceSourceMaterial(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubstanceSourceMaterial"] = r
	}
	if c, ok := w.Concrete.(SubstanceSourceMaterialSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceSourceMaterial(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubstanceSourceMaterial", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubstanceSourceMaterial-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubstanceSourceMaterial"] = r
		}
	}
	if _, ok := w.Concrete.(SupplyDeliveryCreate); ok {
		resourcesMap["SupplyDelivery"] = addInteraction("SupplyDelivery", "create")
	}
	if _, ok := w.Concrete.(SupplyDeliveryRead); ok {
		resourcesMap["SupplyDelivery"] = addInteraction("SupplyDelivery", "read")
	}
	if _, ok := w.Concrete.(SupplyDeliveryDelete); ok {
		resourcesMap["SupplyDelivery"] = addInteraction("SupplyDelivery", "delete")
	}
	if c, ok := w.Concrete.(SupplyDeliveryUpdate); ok {
		r := addInteraction("SupplyDelivery", "update")
		c, ok := c.(SupplyDeliveryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSupplyDelivery(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SupplyDelivery"] = r
	}
	if c, ok := w.Concrete.(SupplyDeliverySearch); ok {
		c, err := c.SearchCapabilitiesSupplyDelivery(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SupplyDelivery", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SupplyDelivery-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SupplyDelivery"] = r
		}
	}
	if _, ok := w.Concrete.(SupplyRequestCreate); ok {
		resourcesMap["SupplyRequest"] = addInteraction("SupplyRequest", "create")
	}
	if _, ok := w.Concrete.(SupplyRequestRead); ok {
		resourcesMap["SupplyRequest"] = addInteraction("SupplyRequest", "read")
	}
	if _, ok := w.Concrete.(SupplyRequestDelete); ok {
		resourcesMap["SupplyRequest"] = addInteraction("SupplyRequest", "delete")
	}
	if c, ok := w.Concrete.(SupplyRequestUpdate); ok {
		r := addInteraction("SupplyRequest", "update")
		c, ok := c.(SupplyRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSupplyRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SupplyRequest"] = r
	}
	if c, ok := w.Concrete.(SupplyRequestSearch); ok {
		c, err := c.SearchCapabilitiesSupplyRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SupplyRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SupplyRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SupplyRequest"] = r
		}
	}
	if _, ok := w.Concrete.(TaskCreate); ok {
		resourcesMap["Task"] = addInteraction("Task", "create")
	}
	if _, ok := w.Concrete.(TaskRead); ok {
		resourcesMap["Task"] = addInteraction("Task", "read")
	}
	if _, ok := w.Concrete.(TaskDelete); ok {
		resourcesMap["Task"] = addInteraction("Task", "delete")
	}
	if c, ok := w.Concrete.(TaskUpdate); ok {
		r := addInteraction("Task", "update")
		c, ok := c.(TaskUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTask(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Task"] = r
	}
	if c, ok := w.Concrete.(TaskSearch); ok {
		c, err := c.SearchCapabilitiesTask(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Task", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Task-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Task"] = r
		}
	}
	if _, ok := w.Concrete.(TerminologyCapabilitiesCreate); ok {
		resourcesMap["TerminologyCapabilities"] = addInteraction("TerminologyCapabilities", "create")
	}
	if _, ok := w.Concrete.(TerminologyCapabilitiesRead); ok {
		resourcesMap["TerminologyCapabilities"] = addInteraction("TerminologyCapabilities", "read")
	}
	if _, ok := w.Concrete.(TerminologyCapabilitiesDelete); ok {
		resourcesMap["TerminologyCapabilities"] = addInteraction("TerminologyCapabilities", "delete")
	}
	if c, ok := w.Concrete.(TerminologyCapabilitiesUpdate); ok {
		r := addInteraction("TerminologyCapabilities", "update")
		c, ok := c.(TerminologyCapabilitiesUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTerminologyCapabilities(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["TerminologyCapabilities"] = r
	}
	if c, ok := w.Concrete.(TerminologyCapabilitiesSearch); ok {
		c, err := c.SearchCapabilitiesTerminologyCapabilities(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("TerminologyCapabilities", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("TerminologyCapabilities-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["TerminologyCapabilities"] = r
		}
	}
	if _, ok := w.Concrete.(TestPlanCreate); ok {
		resourcesMap["TestPlan"] = addInteraction("TestPlan", "create")
	}
	if _, ok := w.Concrete.(TestPlanRead); ok {
		resourcesMap["TestPlan"] = addInteraction("TestPlan", "read")
	}
	if _, ok := w.Concrete.(TestPlanDelete); ok {
		resourcesMap["TestPlan"] = addInteraction("TestPlan", "delete")
	}
	if c, ok := w.Concrete.(TestPlanUpdate); ok {
		r := addInteraction("TestPlan", "update")
		c, ok := c.(TestPlanUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTestPlan(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["TestPlan"] = r
	}
	if c, ok := w.Concrete.(TestPlanSearch); ok {
		c, err := c.SearchCapabilitiesTestPlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("TestPlan", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("TestPlan-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["TestPlan"] = r
		}
	}
	if _, ok := w.Concrete.(TestReportCreate); ok {
		resourcesMap["TestReport"] = addInteraction("TestReport", "create")
	}
	if _, ok := w.Concrete.(TestReportRead); ok {
		resourcesMap["TestReport"] = addInteraction("TestReport", "read")
	}
	if _, ok := w.Concrete.(TestReportDelete); ok {
		resourcesMap["TestReport"] = addInteraction("TestReport", "delete")
	}
	if c, ok := w.Concrete.(TestReportUpdate); ok {
		r := addInteraction("TestReport", "update")
		c, ok := c.(TestReportUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTestReport(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["TestReport"] = r
	}
	if c, ok := w.Concrete.(TestReportSearch); ok {
		c, err := c.SearchCapabilitiesTestReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("TestReport", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("TestReport-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["TestReport"] = r
		}
	}
	if _, ok := w.Concrete.(TestScriptCreate); ok {
		resourcesMap["TestScript"] = addInteraction("TestScript", "create")
	}
	if _, ok := w.Concrete.(TestScriptRead); ok {
		resourcesMap["TestScript"] = addInteraction("TestScript", "read")
	}
	if _, ok := w.Concrete.(TestScriptDelete); ok {
		resourcesMap["TestScript"] = addInteraction("TestScript", "delete")
	}
	if c, ok := w.Concrete.(TestScriptUpdate); ok {
		r := addInteraction("TestScript", "update")
		c, ok := c.(TestScriptUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTestScript(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["TestScript"] = r
	}
	if c, ok := w.Concrete.(TestScriptSearch); ok {
		c, err := c.SearchCapabilitiesTestScript(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("TestScript", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("TestScript-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["TestScript"] = r
		}
	}
	if _, ok := w.Concrete.(TransportCreate); ok {
		resourcesMap["Transport"] = addInteraction("Transport", "create")
	}
	if _, ok := w.Concrete.(TransportRead); ok {
		resourcesMap["Transport"] = addInteraction("Transport", "read")
	}
	if _, ok := w.Concrete.(TransportDelete); ok {
		resourcesMap["Transport"] = addInteraction("Transport", "delete")
	}
	if c, ok := w.Concrete.(TransportUpdate); ok {
		r := addInteraction("Transport", "update")
		c, ok := c.(TransportUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTransport(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Transport"] = r
	}
	if c, ok := w.Concrete.(TransportSearch); ok {
		c, err := c.SearchCapabilitiesTransport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Transport", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Transport-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Transport"] = r
		}
	}
	if _, ok := w.Concrete.(ValueSetCreate); ok {
		resourcesMap["ValueSet"] = addInteraction("ValueSet", "create")
	}
	if _, ok := w.Concrete.(ValueSetRead); ok {
		resourcesMap["ValueSet"] = addInteraction("ValueSet", "read")
	}
	if _, ok := w.Concrete.(ValueSetDelete); ok {
		resourcesMap["ValueSet"] = addInteraction("ValueSet", "delete")
	}
	if c, ok := w.Concrete.(ValueSetUpdate); ok {
		r := addInteraction("ValueSet", "update")
		c, ok := c.(ValueSetUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesValueSet(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ValueSet"] = r
	}
	if c, ok := w.Concrete.(ValueSetSearch); ok {
		c, err := c.SearchCapabilitiesValueSet(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ValueSet", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ValueSet-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ValueSet"] = r
		}
	}
	if _, ok := w.Concrete.(VerificationResultCreate); ok {
		resourcesMap["VerificationResult"] = addInteraction("VerificationResult", "create")
	}
	if _, ok := w.Concrete.(VerificationResultRead); ok {
		resourcesMap["VerificationResult"] = addInteraction("VerificationResult", "read")
	}
	if _, ok := w.Concrete.(VerificationResultDelete); ok {
		resourcesMap["VerificationResult"] = addInteraction("VerificationResult", "delete")
	}
	if c, ok := w.Concrete.(VerificationResultUpdate); ok {
		r := addInteraction("VerificationResult", "update")
		c, ok := c.(VerificationResultUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesVerificationResult(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["VerificationResult"] = r
	}
	if c, ok := w.Concrete.(VerificationResultSearch); ok {
		c, err := c.SearchCapabilitiesVerificationResult(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("VerificationResult", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("VerificationResult-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["VerificationResult"] = r
		}
	}
	if _, ok := w.Concrete.(VisionPrescriptionCreate); ok {
		resourcesMap["VisionPrescription"] = addInteraction("VisionPrescription", "create")
	}
	if _, ok := w.Concrete.(VisionPrescriptionRead); ok {
		resourcesMap["VisionPrescription"] = addInteraction("VisionPrescription", "read")
	}
	if _, ok := w.Concrete.(VisionPrescriptionDelete); ok {
		resourcesMap["VisionPrescription"] = addInteraction("VisionPrescription", "delete")
	}
	if c, ok := w.Concrete.(VisionPrescriptionUpdate); ok {
		r := addInteraction("VisionPrescription", "update")
		c, ok := c.(VisionPrescriptionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesVisionPrescription(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &basic.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["VisionPrescription"] = r
	}
	if c, ok := w.Concrete.(VisionPrescriptionSearch); ok {
		c, err := c.SearchCapabilitiesVisionPrescription(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("VisionPrescription", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, basic.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *basic.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("VisionPrescription-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &basic.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       basic.String{Value: &n},
					Type:       basic.Code{Value: &resolvedType},
				})
			}
			resourcesMap["VisionPrescription"] = r
		}
	}
	if _, ok := w.Concrete.(SearchParameterSearch); !ok {
		resourcesMap["SearchParameter"] = addInteraction("SearchParameter", "read")
		spResource := addInteraction("SearchParameter", "search-type")
		idParam := "_id"
		tokenType := "token"
		idDefinition := baseUrl + "/SearchParameter/SearchParameter-id"
		spResource.SearchParam = append(spResource.SearchParam, basic.CapabilityStatementRestResourceSearchParam{
			Definition: &basic.Canonical{Value: &idDefinition},
			Name:       basic.String{Value: &idParam},
			Type:       basic.Code{Value: &tokenType},
		})
		resourcesMap["SearchParameter"] = spResource
	}
	if len(errs) > 0 {
		return basic.CapabilityStatement{}, errors.Join(errs...)
	}
	resourcesList := make([]basic.CapabilityStatementRestResource, 0, len(resourcesMap))
	for _, r := range resourcesMap {
		slices.SortStableFunc(r.SearchParam, func(a, b basic.CapabilityStatementRestResourceSearchParam) int {
			return cmp.Compare(*a.Name.Value, *b.Name.Value)
		})
		slices.SortStableFunc(r.Interaction, func(a, b basic.CapabilityStatementRestResourceInteraction) int {
			order := map[string]int{
				"create":      1,
				"delete":      4,
				"read":        2,
				"search-type": 5,
				"update":      3,
			}
			aCode := ""
			if a.Code.Value != nil {
				aCode = *a.Code.Value
			}
			bCode := ""
			if b.Code.Value != nil {
				bCode = *b.Code.Value
			}
			return cmp.Compare(order[aCode], order[bCode])
		})
		resourcesList = append(resourcesList, r)
	}
	slices.SortFunc(resourcesList, func(a, b basic.CapabilityStatementRestResource) int {
		return cmp.Compare(*a.Type.Value, *b.Type.Value)
	})
	capabilityStatement := baseCapabilityStatement
	if capabilityStatement.FhirVersion.Value == nil {
		capabilityStatement.FhirVersion = basic.Code{Value: ptr.To("5.0")}
	}
	if len(capabilityStatement.Rest) == 0 {
		capabilityStatement.Rest = []basic.CapabilityStatementRest{{Mode: basic.Code{Value: ptr.To("server")}}}
	}
	capabilityStatement.Rest[0].Resource = resourcesList
	return capabilityStatement, nil
}
func sanitizeIdentifier(input string) string {
	result := strings.ReplaceAll(input, "_", "")
	return result
}
func populateSearchParameter(searchParam r5.SearchParameter, resourceType string, paramName string, baseUrl string) r5.SearchParameter {
	_, idOk, idErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("id"))
	if !idOk || idErr != nil {
		// Set auto-generated ID using pattern {resourceType}-{name} (FHIR-compliant)
		id := sanitizeIdentifier(resourceType + "-" + paramName)
		searchParam.Id = &r5.Id{Value: ptr.To(id)}
	}
	_, urlOk, urlErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("url"))
	if !urlOk || urlErr != nil {
		// Set canonical URL using sanitized ID
		canonicalUrl := baseUrl + "/SearchParameter/" + *searchParam.Id.Value
		searchParam.Url = r5.Uri{Value: ptr.To(canonicalUrl)}
	}
	_, nameOk, nameErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("name"))
	if !nameOk || nameErr != nil {
		// Set name based on parameter name
		searchParam.Name = r5.String{Value: ptr.To(paramName)}
	}
	_, statusOk, statusErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("status"))
	if !statusOk || statusErr != nil {
		// Set default status to active
		searchParam.Status = r5.Code{Value: ptr.To("active")}
	}
	_, codeOk, codeErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("code"))
	if !codeOk || codeErr != nil {
		// Set code based on parameter name
		searchParam.Code = r5.Code{Value: ptr.To(paramName)}
	}
	baseElements := searchParam.Children("base")
	if len(baseElements) == 0 {
		// Set base resource type
		searchParam.Base = []r5.Code{{Value: ptr.To(resourceType)}}
	}
	_, descOk, descErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("description"))
	if !descOk || descErr != nil {
		// Set default description
		description := "Search parameter " + paramName + " for " + resourceType + " resource"
		searchParam.Description = r5.Markdown{Value: ptr.To(description)}
	}
	return searchParam
}
func searchParameters(ctx context.Context, api any, baseUrl string) (map[string]r5.SearchParameter, error) {
	searchParameters := make(map[string]r5.SearchParameter)
	var errs []error
	if c, ok := api.(AccountSearch); ok {
		c, err := c.SearchCapabilitiesAccount(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Account", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Account"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ActivityDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesActivityDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ActivityDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ActivityDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ActorDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesActorDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ActorDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ActorDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AdministrableProductDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesAdministrableProductDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AdministrableProductDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AdministrableProductDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AdverseEventSearch); ok {
		c, err := c.SearchCapabilitiesAdverseEvent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AdverseEvent", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AdverseEvent"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AllergyIntoleranceSearch); ok {
		c, err := c.SearchCapabilitiesAllergyIntolerance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AllergyIntolerance", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AllergyIntolerance"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AppointmentSearch); ok {
		c, err := c.SearchCapabilitiesAppointment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Appointment", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Appointment"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AppointmentResponseSearch); ok {
		c, err := c.SearchCapabilitiesAppointmentResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AppointmentResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AppointmentResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ArtifactAssessmentSearch); ok {
		c, err := c.SearchCapabilitiesArtifactAssessment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ArtifactAssessment", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ArtifactAssessment"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AuditEventSearch); ok {
		c, err := c.SearchCapabilitiesAuditEvent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AuditEvent", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AuditEvent"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BasicSearch); ok {
		c, err := c.SearchCapabilitiesBasic(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Basic", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Basic"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BinarySearch); ok {
		c, err := c.SearchCapabilitiesBinary(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Binary", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Binary"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BiologicallyDerivedProductSearch); ok {
		c, err := c.SearchCapabilitiesBiologicallyDerivedProduct(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "BiologicallyDerivedProduct", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["BiologicallyDerivedProduct"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BiologicallyDerivedProductDispenseSearch); ok {
		c, err := c.SearchCapabilitiesBiologicallyDerivedProductDispense(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "BiologicallyDerivedProductDispense", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["BiologicallyDerivedProductDispense"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BodyStructureSearch); ok {
		c, err := c.SearchCapabilitiesBodyStructure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "BodyStructure", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["BodyStructure"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BundleSearch); ok {
		c, err := c.SearchCapabilitiesBundle(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Bundle", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Bundle"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CapabilityStatementSearch); ok {
		c, err := c.SearchCapabilitiesCapabilityStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CapabilityStatement", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CapabilityStatement"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CarePlanSearch); ok {
		c, err := c.SearchCapabilitiesCarePlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CarePlan", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CarePlan"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CareTeamSearch); ok {
		c, err := c.SearchCapabilitiesCareTeam(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CareTeam", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CareTeam"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ChargeItemSearch); ok {
		c, err := c.SearchCapabilitiesChargeItem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ChargeItem", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ChargeItem"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ChargeItemDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesChargeItemDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ChargeItemDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ChargeItemDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CitationSearch); ok {
		c, err := c.SearchCapabilitiesCitation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Citation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Citation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ClaimSearch); ok {
		c, err := c.SearchCapabilitiesClaim(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Claim", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Claim"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ClaimResponseSearch); ok {
		c, err := c.SearchCapabilitiesClaimResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ClaimResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ClaimResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ClinicalImpressionSearch); ok {
		c, err := c.SearchCapabilitiesClinicalImpression(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ClinicalImpression", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ClinicalImpression"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ClinicalUseDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesClinicalUseDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ClinicalUseDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ClinicalUseDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CodeSystemSearch); ok {
		c, err := c.SearchCapabilitiesCodeSystem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CodeSystem", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CodeSystem"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CommunicationSearch); ok {
		c, err := c.SearchCapabilitiesCommunication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Communication", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Communication"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CommunicationRequestSearch); ok {
		c, err := c.SearchCapabilitiesCommunicationRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CommunicationRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CommunicationRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CompartmentDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesCompartmentDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CompartmentDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CompartmentDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CompositionSearch); ok {
		c, err := c.SearchCapabilitiesComposition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Composition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Composition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ConceptMapSearch); ok {
		c, err := c.SearchCapabilitiesConceptMap(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ConceptMap", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ConceptMap"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ConditionSearch); ok {
		c, err := c.SearchCapabilitiesCondition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Condition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Condition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ConditionDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesConditionDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ConditionDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ConditionDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ConsentSearch); ok {
		c, err := c.SearchCapabilitiesConsent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Consent", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Consent"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ContractSearch); ok {
		c, err := c.SearchCapabilitiesContract(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Contract", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Contract"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CoverageSearch); ok {
		c, err := c.SearchCapabilitiesCoverage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Coverage", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Coverage"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CoverageEligibilityRequestSearch); ok {
		c, err := c.SearchCapabilitiesCoverageEligibilityRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CoverageEligibilityRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CoverageEligibilityRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CoverageEligibilityResponseSearch); ok {
		c, err := c.SearchCapabilitiesCoverageEligibilityResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CoverageEligibilityResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CoverageEligibilityResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DetectedIssueSearch); ok {
		c, err := c.SearchCapabilitiesDetectedIssue(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DetectedIssue", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DetectedIssue"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceSearch); ok {
		c, err := c.SearchCapabilitiesDevice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Device", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Device"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceAssociationSearch); ok {
		c, err := c.SearchCapabilitiesDeviceAssociation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceAssociation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceAssociation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesDeviceDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceDispenseSearch); ok {
		c, err := c.SearchCapabilitiesDeviceDispense(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceDispense", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceDispense"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceMetricSearch); ok {
		c, err := c.SearchCapabilitiesDeviceMetric(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceMetric", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceMetric"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceRequestSearch); ok {
		c, err := c.SearchCapabilitiesDeviceRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceUsageSearch); ok {
		c, err := c.SearchCapabilitiesDeviceUsage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceUsage", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceUsage"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DiagnosticReportSearch); ok {
		c, err := c.SearchCapabilitiesDiagnosticReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DiagnosticReport", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DiagnosticReport"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DocumentReferenceSearch); ok {
		c, err := c.SearchCapabilitiesDocumentReference(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DocumentReference", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DocumentReference"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EncounterSearch); ok {
		c, err := c.SearchCapabilitiesEncounter(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Encounter", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Encounter"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EncounterHistorySearch); ok {
		c, err := c.SearchCapabilitiesEncounterHistory(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EncounterHistory", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EncounterHistory"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EndpointSearch); ok {
		c, err := c.SearchCapabilitiesEndpoint(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Endpoint", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Endpoint"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EnrollmentRequestSearch); ok {
		c, err := c.SearchCapabilitiesEnrollmentRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EnrollmentRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EnrollmentRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EnrollmentResponseSearch); ok {
		c, err := c.SearchCapabilitiesEnrollmentResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EnrollmentResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EnrollmentResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EpisodeOfCareSearch); ok {
		c, err := c.SearchCapabilitiesEpisodeOfCare(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EpisodeOfCare", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EpisodeOfCare"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EventDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesEventDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EventDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EventDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EvidenceSearch); ok {
		c, err := c.SearchCapabilitiesEvidence(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Evidence", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Evidence"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EvidenceReportSearch); ok {
		c, err := c.SearchCapabilitiesEvidenceReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EvidenceReport", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EvidenceReport"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EvidenceVariableSearch); ok {
		c, err := c.SearchCapabilitiesEvidenceVariable(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EvidenceVariable", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EvidenceVariable"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ExampleScenarioSearch); ok {
		c, err := c.SearchCapabilitiesExampleScenario(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ExampleScenario", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ExampleScenario"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ExplanationOfBenefitSearch); ok {
		c, err := c.SearchCapabilitiesExplanationOfBenefit(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ExplanationOfBenefit", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ExplanationOfBenefit"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(FamilyMemberHistorySearch); ok {
		c, err := c.SearchCapabilitiesFamilyMemberHistory(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "FamilyMemberHistory", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["FamilyMemberHistory"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(FlagSearch); ok {
		c, err := c.SearchCapabilitiesFlag(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Flag", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Flag"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(FormularyItemSearch); ok {
		c, err := c.SearchCapabilitiesFormularyItem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "FormularyItem", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["FormularyItem"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(GenomicStudySearch); ok {
		c, err := c.SearchCapabilitiesGenomicStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "GenomicStudy", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["GenomicStudy"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(GoalSearch); ok {
		c, err := c.SearchCapabilitiesGoal(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Goal", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Goal"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(GraphDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesGraphDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "GraphDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["GraphDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(GroupSearch); ok {
		c, err := c.SearchCapabilitiesGroup(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Group", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Group"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(GuidanceResponseSearch); ok {
		c, err := c.SearchCapabilitiesGuidanceResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "GuidanceResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["GuidanceResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(HealthcareServiceSearch); ok {
		c, err := c.SearchCapabilitiesHealthcareService(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "HealthcareService", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["HealthcareService"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImagingSelectionSearch); ok {
		c, err := c.SearchCapabilitiesImagingSelection(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ImagingSelection", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ImagingSelection"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImagingStudySearch); ok {
		c, err := c.SearchCapabilitiesImagingStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ImagingStudy", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ImagingStudy"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImmunizationSearch); ok {
		c, err := c.SearchCapabilitiesImmunization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Immunization", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Immunization"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImmunizationEvaluationSearch); ok {
		c, err := c.SearchCapabilitiesImmunizationEvaluation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ImmunizationEvaluation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ImmunizationEvaluation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImmunizationRecommendationSearch); ok {
		c, err := c.SearchCapabilitiesImmunizationRecommendation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ImmunizationRecommendation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ImmunizationRecommendation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImplementationGuideSearch); ok {
		c, err := c.SearchCapabilitiesImplementationGuide(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ImplementationGuide", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ImplementationGuide"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(IngredientSearch); ok {
		c, err := c.SearchCapabilitiesIngredient(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Ingredient", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Ingredient"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(InsurancePlanSearch); ok {
		c, err := c.SearchCapabilitiesInsurancePlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "InsurancePlan", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["InsurancePlan"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(InventoryItemSearch); ok {
		c, err := c.SearchCapabilitiesInventoryItem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "InventoryItem", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["InventoryItem"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(InventoryReportSearch); ok {
		c, err := c.SearchCapabilitiesInventoryReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "InventoryReport", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["InventoryReport"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(InvoiceSearch); ok {
		c, err := c.SearchCapabilitiesInvoice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Invoice", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Invoice"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(LibrarySearch); ok {
		c, err := c.SearchCapabilitiesLibrary(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Library", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Library"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(LinkageSearch); ok {
		c, err := c.SearchCapabilitiesLinkage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Linkage", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Linkage"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ListSearch); ok {
		c, err := c.SearchCapabilitiesList(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "List", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["List"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(LocationSearch); ok {
		c, err := c.SearchCapabilitiesLocation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Location", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Location"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ManufacturedItemDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesManufacturedItemDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ManufacturedItemDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ManufacturedItemDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MeasureSearch); ok {
		c, err := c.SearchCapabilitiesMeasure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Measure", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Measure"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MeasureReportSearch); ok {
		c, err := c.SearchCapabilitiesMeasureReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MeasureReport", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MeasureReport"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationSearch); ok {
		c, err := c.SearchCapabilitiesMedication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Medication", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Medication"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationAdministrationSearch); ok {
		c, err := c.SearchCapabilitiesMedicationAdministration(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationAdministration", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationAdministration"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationDispenseSearch); ok {
		c, err := c.SearchCapabilitiesMedicationDispense(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationDispense", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationDispense"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationKnowledgeSearch); ok {
		c, err := c.SearchCapabilitiesMedicationKnowledge(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationKnowledge", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationKnowledge"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationRequestSearch); ok {
		c, err := c.SearchCapabilitiesMedicationRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationStatementSearch); ok {
		c, err := c.SearchCapabilitiesMedicationStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationStatement", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationStatement"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicinalProductDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicinalProductDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicinalProductDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MessageDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesMessageDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MessageDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MessageDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MessageHeaderSearch); ok {
		c, err := c.SearchCapabilitiesMessageHeader(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MessageHeader", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MessageHeader"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MolecularSequenceSearch); ok {
		c, err := c.SearchCapabilitiesMolecularSequence(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MolecularSequence", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MolecularSequence"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(NamingSystemSearch); ok {
		c, err := c.SearchCapabilitiesNamingSystem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "NamingSystem", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["NamingSystem"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(NutritionIntakeSearch); ok {
		c, err := c.SearchCapabilitiesNutritionIntake(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "NutritionIntake", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["NutritionIntake"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(NutritionOrderSearch); ok {
		c, err := c.SearchCapabilitiesNutritionOrder(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "NutritionOrder", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["NutritionOrder"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(NutritionProductSearch); ok {
		c, err := c.SearchCapabilitiesNutritionProduct(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "NutritionProduct", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["NutritionProduct"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ObservationSearch); ok {
		c, err := c.SearchCapabilitiesObservation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Observation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Observation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ObservationDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesObservationDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ObservationDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ObservationDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(OperationDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesOperationDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "OperationDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["OperationDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(OperationOutcomeSearch); ok {
		c, err := c.SearchCapabilitiesOperationOutcome(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "OperationOutcome", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["OperationOutcome"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(OrganizationSearch); ok {
		c, err := c.SearchCapabilitiesOrganization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Organization", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Organization"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(OrganizationAffiliationSearch); ok {
		c, err := c.SearchCapabilitiesOrganizationAffiliation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "OrganizationAffiliation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["OrganizationAffiliation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PackagedProductDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesPackagedProductDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PackagedProductDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PackagedProductDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ParametersSearch); ok {
		c, err := c.SearchCapabilitiesParameters(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Parameters", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Parameters"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PatientSearch); ok {
		c, err := c.SearchCapabilitiesPatient(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Patient", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Patient"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PaymentNoticeSearch); ok {
		c, err := c.SearchCapabilitiesPaymentNotice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PaymentNotice", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PaymentNotice"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PaymentReconciliationSearch); ok {
		c, err := c.SearchCapabilitiesPaymentReconciliation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PaymentReconciliation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PaymentReconciliation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PermissionSearch); ok {
		c, err := c.SearchCapabilitiesPermission(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Permission", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Permission"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PersonSearch); ok {
		c, err := c.SearchCapabilitiesPerson(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Person", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Person"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PlanDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesPlanDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PlanDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PlanDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PractitionerSearch); ok {
		c, err := c.SearchCapabilitiesPractitioner(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Practitioner", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Practitioner"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PractitionerRoleSearch); ok {
		c, err := c.SearchCapabilitiesPractitionerRole(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PractitionerRole", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PractitionerRole"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ProcedureSearch); ok {
		c, err := c.SearchCapabilitiesProcedure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Procedure", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Procedure"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ProvenanceSearch); ok {
		c, err := c.SearchCapabilitiesProvenance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Provenance", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Provenance"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(QuestionnaireSearch); ok {
		c, err := c.SearchCapabilitiesQuestionnaire(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Questionnaire", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Questionnaire"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(QuestionnaireResponseSearch); ok {
		c, err := c.SearchCapabilitiesQuestionnaireResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "QuestionnaireResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["QuestionnaireResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(RegulatedAuthorizationSearch); ok {
		c, err := c.SearchCapabilitiesRegulatedAuthorization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "RegulatedAuthorization", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["RegulatedAuthorization"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(RelatedPersonSearch); ok {
		c, err := c.SearchCapabilitiesRelatedPerson(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "RelatedPerson", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["RelatedPerson"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(RequestOrchestrationSearch); ok {
		c, err := c.SearchCapabilitiesRequestOrchestration(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "RequestOrchestration", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["RequestOrchestration"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(RequirementsSearch); ok {
		c, err := c.SearchCapabilitiesRequirements(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Requirements", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Requirements"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ResearchStudySearch); ok {
		c, err := c.SearchCapabilitiesResearchStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ResearchStudy", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ResearchStudy"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ResearchSubjectSearch); ok {
		c, err := c.SearchCapabilitiesResearchSubject(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ResearchSubject", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ResearchSubject"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(RiskAssessmentSearch); ok {
		c, err := c.SearchCapabilitiesRiskAssessment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "RiskAssessment", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["RiskAssessment"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ScheduleSearch); ok {
		c, err := c.SearchCapabilitiesSchedule(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Schedule", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Schedule"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SearchParameterSearch); ok {
		c, err := c.SearchCapabilitiesSearchParameter(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SearchParameter", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SearchParameter"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ServiceRequestSearch); ok {
		c, err := c.SearchCapabilitiesServiceRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ServiceRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ServiceRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SlotSearch); ok {
		c, err := c.SearchCapabilitiesSlot(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Slot", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Slot"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SpecimenSearch); ok {
		c, err := c.SearchCapabilitiesSpecimen(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Specimen", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Specimen"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SpecimenDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesSpecimenDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SpecimenDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SpecimenDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(StructureDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesStructureDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "StructureDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["StructureDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(StructureMapSearch); ok {
		c, err := c.SearchCapabilitiesStructureMap(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "StructureMap", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["StructureMap"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubscriptionSearch); ok {
		c, err := c.SearchCapabilitiesSubscription(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Subscription", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Subscription"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubscriptionStatusSearch); ok {
		c, err := c.SearchCapabilitiesSubscriptionStatus(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubscriptionStatus", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubscriptionStatus"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubscriptionTopicSearch); ok {
		c, err := c.SearchCapabilitiesSubscriptionTopic(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubscriptionTopic", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubscriptionTopic"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceSearch); ok {
		c, err := c.SearchCapabilitiesSubstance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Substance", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Substance"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubstanceDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubstanceDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceNucleicAcidSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceNucleicAcid(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubstanceNucleicAcid", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubstanceNucleicAcid"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstancePolymerSearch); ok {
		c, err := c.SearchCapabilitiesSubstancePolymer(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubstancePolymer", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubstancePolymer"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceProteinSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceProtein(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubstanceProtein", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubstanceProtein"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceReferenceInformationSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceReferenceInformation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubstanceReferenceInformation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubstanceReferenceInformation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceSourceMaterialSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceSourceMaterial(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubstanceSourceMaterial", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubstanceSourceMaterial"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SupplyDeliverySearch); ok {
		c, err := c.SearchCapabilitiesSupplyDelivery(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SupplyDelivery", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SupplyDelivery"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SupplyRequestSearch); ok {
		c, err := c.SearchCapabilitiesSupplyRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SupplyRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SupplyRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TaskSearch); ok {
		c, err := c.SearchCapabilitiesTask(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Task", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Task"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TerminologyCapabilitiesSearch); ok {
		c, err := c.SearchCapabilitiesTerminologyCapabilities(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "TerminologyCapabilities", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["TerminologyCapabilities"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TestPlanSearch); ok {
		c, err := c.SearchCapabilitiesTestPlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "TestPlan", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["TestPlan"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TestReportSearch); ok {
		c, err := c.SearchCapabilitiesTestReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "TestReport", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["TestReport"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TestScriptSearch); ok {
		c, err := c.SearchCapabilitiesTestScript(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "TestScript", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["TestScript"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TransportSearch); ok {
		c, err := c.SearchCapabilitiesTransport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Transport", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Transport"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ValueSetSearch); ok {
		c, err := c.SearchCapabilitiesValueSet(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ValueSet", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ValueSet"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(VerificationResultSearch); ok {
		c, err := c.SearchCapabilitiesVerificationResult(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "VerificationResult", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["VerificationResult"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(VisionPrescriptionSearch); ok {
		c, err := c.SearchCapabilitiesVisionPrescription(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "VisionPrescription", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["VisionPrescription"+"-"+n] = populatedParam
				}
			}
		}
	}
	if len(errs) > 0 {
		return nil, errors.Join(errs...)
	}
	if _, ok := api.(SearchParameterSearch); !ok {
		idParam := r5.SearchParameter{
			Base:        []r5.Code{r5.Code{Value: ptr.To("SearchParameter")}},
			Code:        r5.Code{Value: ptr.To("_id")},
			Description: r5.Markdown{Value: ptr.To("Logical id of this artifact")},
			Expression:  &r5.String{Value: ptr.To("SearchParameter.id")},
			Id:          &r5.Id{Value: ptr.To("SearchParameter-id")},
			Name:        r5.String{Value: ptr.To("_id")},
			Status:      r5.Code{Value: ptr.To("active")},
			Type:        r5.Code{Value: ptr.To("token")},
			Url:         r5.Uri{Value: ptr.To(baseUrl + "/SearchParameter/SearchParameter-id")},
		}
		searchParameters["SearchParameter-id"] = idParam
	}
	return searchParameters, nil
}
func (w Generic) Create(ctx context.Context, resource model.Resource) (model.Resource, error) {
	g, ok := w.Concrete.(capabilities.GenericCreate)
	if ok {
		// shortcut for the case that the underlying implementation already implements the generic API
		return g.Create(ctx, resource)
	}
	switch r := resource.(type) {
	case r5.Account:
		impl, ok := w.Concrete.(AccountCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Account")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateAccount(ctx, r)
	case r5.ActivityDefinition:
		impl, ok := w.Concrete.(ActivityDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ActivityDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateActivityDefinition(ctx, r)
	case r5.ActorDefinition:
		impl, ok := w.Concrete.(ActorDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ActorDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateActorDefinition(ctx, r)
	case r5.AdministrableProductDefinition:
		impl, ok := w.Concrete.(AdministrableProductDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for AdministrableProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateAdministrableProductDefinition(ctx, r)
	case r5.AdverseEvent:
		impl, ok := w.Concrete.(AdverseEventCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for AdverseEvent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateAdverseEvent(ctx, r)
	case r5.AllergyIntolerance:
		impl, ok := w.Concrete.(AllergyIntoleranceCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for AllergyIntolerance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateAllergyIntolerance(ctx, r)
	case r5.Appointment:
		impl, ok := w.Concrete.(AppointmentCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Appointment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateAppointment(ctx, r)
	case r5.AppointmentResponse:
		impl, ok := w.Concrete.(AppointmentResponseCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for AppointmentResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateAppointmentResponse(ctx, r)
	case r5.ArtifactAssessment:
		impl, ok := w.Concrete.(ArtifactAssessmentCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ArtifactAssessment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateArtifactAssessment(ctx, r)
	case r5.AuditEvent:
		impl, ok := w.Concrete.(AuditEventCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for AuditEvent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateAuditEvent(ctx, r)
	case r5.Basic:
		impl, ok := w.Concrete.(BasicCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Basic")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateBasic(ctx, r)
	case r5.Binary:
		impl, ok := w.Concrete.(BinaryCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Binary")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateBinary(ctx, r)
	case r5.BiologicallyDerivedProduct:
		impl, ok := w.Concrete.(BiologicallyDerivedProductCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for BiologicallyDerivedProduct")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateBiologicallyDerivedProduct(ctx, r)
	case r5.BiologicallyDerivedProductDispense:
		impl, ok := w.Concrete.(BiologicallyDerivedProductDispenseCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for BiologicallyDerivedProductDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateBiologicallyDerivedProductDispense(ctx, r)
	case r5.BodyStructure:
		impl, ok := w.Concrete.(BodyStructureCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for BodyStructure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateBodyStructure(ctx, r)
	case r5.Bundle:
		impl, ok := w.Concrete.(BundleCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Bundle")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateBundle(ctx, r)
	case r5.CapabilityStatement:
		impl, ok := w.Concrete.(CapabilityStatementCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for CapabilityStatement")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCapabilityStatement(ctx, r)
	case r5.CarePlan:
		impl, ok := w.Concrete.(CarePlanCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for CarePlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCarePlan(ctx, r)
	case r5.CareTeam:
		impl, ok := w.Concrete.(CareTeamCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for CareTeam")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCareTeam(ctx, r)
	case r5.ChargeItem:
		impl, ok := w.Concrete.(ChargeItemCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ChargeItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateChargeItem(ctx, r)
	case r5.ChargeItemDefinition:
		impl, ok := w.Concrete.(ChargeItemDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ChargeItemDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateChargeItemDefinition(ctx, r)
	case r5.Citation:
		impl, ok := w.Concrete.(CitationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Citation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCitation(ctx, r)
	case r5.Claim:
		impl, ok := w.Concrete.(ClaimCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Claim")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateClaim(ctx, r)
	case r5.ClaimResponse:
		impl, ok := w.Concrete.(ClaimResponseCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ClaimResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateClaimResponse(ctx, r)
	case r5.ClinicalImpression:
		impl, ok := w.Concrete.(ClinicalImpressionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ClinicalImpression")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateClinicalImpression(ctx, r)
	case r5.ClinicalUseDefinition:
		impl, ok := w.Concrete.(ClinicalUseDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ClinicalUseDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateClinicalUseDefinition(ctx, r)
	case r5.CodeSystem:
		impl, ok := w.Concrete.(CodeSystemCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for CodeSystem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCodeSystem(ctx, r)
	case r5.Communication:
		impl, ok := w.Concrete.(CommunicationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Communication")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCommunication(ctx, r)
	case r5.CommunicationRequest:
		impl, ok := w.Concrete.(CommunicationRequestCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for CommunicationRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCommunicationRequest(ctx, r)
	case r5.CompartmentDefinition:
		impl, ok := w.Concrete.(CompartmentDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for CompartmentDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCompartmentDefinition(ctx, r)
	case r5.Composition:
		impl, ok := w.Concrete.(CompositionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Composition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateComposition(ctx, r)
	case r5.ConceptMap:
		impl, ok := w.Concrete.(ConceptMapCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ConceptMap")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateConceptMap(ctx, r)
	case r5.Condition:
		impl, ok := w.Concrete.(ConditionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Condition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCondition(ctx, r)
	case r5.ConditionDefinition:
		impl, ok := w.Concrete.(ConditionDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ConditionDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateConditionDefinition(ctx, r)
	case r5.Consent:
		impl, ok := w.Concrete.(ConsentCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Consent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateConsent(ctx, r)
	case r5.Contract:
		impl, ok := w.Concrete.(ContractCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Contract")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateContract(ctx, r)
	case r5.Coverage:
		impl, ok := w.Concrete.(CoverageCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Coverage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCoverage(ctx, r)
	case r5.CoverageEligibilityRequest:
		impl, ok := w.Concrete.(CoverageEligibilityRequestCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for CoverageEligibilityRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCoverageEligibilityRequest(ctx, r)
	case r5.CoverageEligibilityResponse:
		impl, ok := w.Concrete.(CoverageEligibilityResponseCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for CoverageEligibilityResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCoverageEligibilityResponse(ctx, r)
	case r5.DetectedIssue:
		impl, ok := w.Concrete.(DetectedIssueCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for DetectedIssue")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDetectedIssue(ctx, r)
	case r5.Device:
		impl, ok := w.Concrete.(DeviceCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Device")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDevice(ctx, r)
	case r5.DeviceAssociation:
		impl, ok := w.Concrete.(DeviceAssociationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for DeviceAssociation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDeviceAssociation(ctx, r)
	case r5.DeviceDefinition:
		impl, ok := w.Concrete.(DeviceDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for DeviceDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDeviceDefinition(ctx, r)
	case r5.DeviceDispense:
		impl, ok := w.Concrete.(DeviceDispenseCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for DeviceDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDeviceDispense(ctx, r)
	case r5.DeviceMetric:
		impl, ok := w.Concrete.(DeviceMetricCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for DeviceMetric")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDeviceMetric(ctx, r)
	case r5.DeviceRequest:
		impl, ok := w.Concrete.(DeviceRequestCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for DeviceRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDeviceRequest(ctx, r)
	case r5.DeviceUsage:
		impl, ok := w.Concrete.(DeviceUsageCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for DeviceUsage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDeviceUsage(ctx, r)
	case r5.DiagnosticReport:
		impl, ok := w.Concrete.(DiagnosticReportCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for DiagnosticReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDiagnosticReport(ctx, r)
	case r5.DocumentReference:
		impl, ok := w.Concrete.(DocumentReferenceCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for DocumentReference")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDocumentReference(ctx, r)
	case r5.Encounter:
		impl, ok := w.Concrete.(EncounterCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Encounter")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEncounter(ctx, r)
	case r5.EncounterHistory:
		impl, ok := w.Concrete.(EncounterHistoryCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for EncounterHistory")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEncounterHistory(ctx, r)
	case r5.Endpoint:
		impl, ok := w.Concrete.(EndpointCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Endpoint")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEndpoint(ctx, r)
	case r5.EnrollmentRequest:
		impl, ok := w.Concrete.(EnrollmentRequestCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for EnrollmentRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEnrollmentRequest(ctx, r)
	case r5.EnrollmentResponse:
		impl, ok := w.Concrete.(EnrollmentResponseCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for EnrollmentResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEnrollmentResponse(ctx, r)
	case r5.EpisodeOfCare:
		impl, ok := w.Concrete.(EpisodeOfCareCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for EpisodeOfCare")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEpisodeOfCare(ctx, r)
	case r5.EventDefinition:
		impl, ok := w.Concrete.(EventDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for EventDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEventDefinition(ctx, r)
	case r5.Evidence:
		impl, ok := w.Concrete.(EvidenceCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Evidence")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEvidence(ctx, r)
	case r5.EvidenceReport:
		impl, ok := w.Concrete.(EvidenceReportCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for EvidenceReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEvidenceReport(ctx, r)
	case r5.EvidenceVariable:
		impl, ok := w.Concrete.(EvidenceVariableCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for EvidenceVariable")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEvidenceVariable(ctx, r)
	case r5.ExampleScenario:
		impl, ok := w.Concrete.(ExampleScenarioCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ExampleScenario")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateExampleScenario(ctx, r)
	case r5.ExplanationOfBenefit:
		impl, ok := w.Concrete.(ExplanationOfBenefitCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ExplanationOfBenefit")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateExplanationOfBenefit(ctx, r)
	case r5.FamilyMemberHistory:
		impl, ok := w.Concrete.(FamilyMemberHistoryCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for FamilyMemberHistory")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateFamilyMemberHistory(ctx, r)
	case r5.Flag:
		impl, ok := w.Concrete.(FlagCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Flag")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateFlag(ctx, r)
	case r5.FormularyItem:
		impl, ok := w.Concrete.(FormularyItemCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for FormularyItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateFormularyItem(ctx, r)
	case r5.GenomicStudy:
		impl, ok := w.Concrete.(GenomicStudyCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for GenomicStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateGenomicStudy(ctx, r)
	case r5.Goal:
		impl, ok := w.Concrete.(GoalCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Goal")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateGoal(ctx, r)
	case r5.GraphDefinition:
		impl, ok := w.Concrete.(GraphDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for GraphDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateGraphDefinition(ctx, r)
	case r5.Group:
		impl, ok := w.Concrete.(GroupCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Group")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateGroup(ctx, r)
	case r5.GuidanceResponse:
		impl, ok := w.Concrete.(GuidanceResponseCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for GuidanceResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateGuidanceResponse(ctx, r)
	case r5.HealthcareService:
		impl, ok := w.Concrete.(HealthcareServiceCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for HealthcareService")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateHealthcareService(ctx, r)
	case r5.ImagingSelection:
		impl, ok := w.Concrete.(ImagingSelectionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ImagingSelection")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateImagingSelection(ctx, r)
	case r5.ImagingStudy:
		impl, ok := w.Concrete.(ImagingStudyCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ImagingStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateImagingStudy(ctx, r)
	case r5.Immunization:
		impl, ok := w.Concrete.(ImmunizationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Immunization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateImmunization(ctx, r)
	case r5.ImmunizationEvaluation:
		impl, ok := w.Concrete.(ImmunizationEvaluationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ImmunizationEvaluation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateImmunizationEvaluation(ctx, r)
	case r5.ImmunizationRecommendation:
		impl, ok := w.Concrete.(ImmunizationRecommendationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ImmunizationRecommendation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateImmunizationRecommendation(ctx, r)
	case r5.ImplementationGuide:
		impl, ok := w.Concrete.(ImplementationGuideCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ImplementationGuide")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateImplementationGuide(ctx, r)
	case r5.Ingredient:
		impl, ok := w.Concrete.(IngredientCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Ingredient")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateIngredient(ctx, r)
	case r5.InsurancePlan:
		impl, ok := w.Concrete.(InsurancePlanCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for InsurancePlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateInsurancePlan(ctx, r)
	case r5.InventoryItem:
		impl, ok := w.Concrete.(InventoryItemCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for InventoryItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateInventoryItem(ctx, r)
	case r5.InventoryReport:
		impl, ok := w.Concrete.(InventoryReportCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for InventoryReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateInventoryReport(ctx, r)
	case r5.Invoice:
		impl, ok := w.Concrete.(InvoiceCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Invoice")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateInvoice(ctx, r)
	case r5.Library:
		impl, ok := w.Concrete.(LibraryCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Library")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateLibrary(ctx, r)
	case r5.Linkage:
		impl, ok := w.Concrete.(LinkageCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Linkage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateLinkage(ctx, r)
	case r5.List:
		impl, ok := w.Concrete.(ListCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for List")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateList(ctx, r)
	case r5.Location:
		impl, ok := w.Concrete.(LocationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Location")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateLocation(ctx, r)
	case r5.ManufacturedItemDefinition:
		impl, ok := w.Concrete.(ManufacturedItemDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ManufacturedItemDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateManufacturedItemDefinition(ctx, r)
	case r5.Measure:
		impl, ok := w.Concrete.(MeasureCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Measure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMeasure(ctx, r)
	case r5.MeasureReport:
		impl, ok := w.Concrete.(MeasureReportCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for MeasureReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMeasureReport(ctx, r)
	case r5.Medication:
		impl, ok := w.Concrete.(MedicationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Medication")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedication(ctx, r)
	case r5.MedicationAdministration:
		impl, ok := w.Concrete.(MedicationAdministrationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for MedicationAdministration")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicationAdministration(ctx, r)
	case r5.MedicationDispense:
		impl, ok := w.Concrete.(MedicationDispenseCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for MedicationDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicationDispense(ctx, r)
	case r5.MedicationKnowledge:
		impl, ok := w.Concrete.(MedicationKnowledgeCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for MedicationKnowledge")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicationKnowledge(ctx, r)
	case r5.MedicationRequest:
		impl, ok := w.Concrete.(MedicationRequestCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for MedicationRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicationRequest(ctx, r)
	case r5.MedicationStatement:
		impl, ok := w.Concrete.(MedicationStatementCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for MedicationStatement")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicationStatement(ctx, r)
	case r5.MedicinalProductDefinition:
		impl, ok := w.Concrete.(MedicinalProductDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for MedicinalProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicinalProductDefinition(ctx, r)
	case r5.MessageDefinition:
		impl, ok := w.Concrete.(MessageDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for MessageDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMessageDefinition(ctx, r)
	case r5.MessageHeader:
		impl, ok := w.Concrete.(MessageHeaderCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for MessageHeader")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMessageHeader(ctx, r)
	case r5.MolecularSequence:
		impl, ok := w.Concrete.(MolecularSequenceCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for MolecularSequence")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMolecularSequence(ctx, r)
	case r5.NamingSystem:
		impl, ok := w.Concrete.(NamingSystemCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for NamingSystem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateNamingSystem(ctx, r)
	case r5.NutritionIntake:
		impl, ok := w.Concrete.(NutritionIntakeCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for NutritionIntake")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateNutritionIntake(ctx, r)
	case r5.NutritionOrder:
		impl, ok := w.Concrete.(NutritionOrderCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for NutritionOrder")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateNutritionOrder(ctx, r)
	case r5.NutritionProduct:
		impl, ok := w.Concrete.(NutritionProductCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for NutritionProduct")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateNutritionProduct(ctx, r)
	case r5.Observation:
		impl, ok := w.Concrete.(ObservationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Observation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateObservation(ctx, r)
	case r5.ObservationDefinition:
		impl, ok := w.Concrete.(ObservationDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ObservationDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateObservationDefinition(ctx, r)
	case r5.OperationDefinition:
		impl, ok := w.Concrete.(OperationDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for OperationDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateOperationDefinition(ctx, r)
	case r5.OperationOutcome:
		impl, ok := w.Concrete.(OperationOutcomeCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for OperationOutcome")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateOperationOutcome(ctx, r)
	case r5.Organization:
		impl, ok := w.Concrete.(OrganizationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Organization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateOrganization(ctx, r)
	case r5.OrganizationAffiliation:
		impl, ok := w.Concrete.(OrganizationAffiliationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for OrganizationAffiliation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateOrganizationAffiliation(ctx, r)
	case r5.PackagedProductDefinition:
		impl, ok := w.Concrete.(PackagedProductDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for PackagedProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePackagedProductDefinition(ctx, r)
	case r5.Parameters:
		impl, ok := w.Concrete.(ParametersCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Parameters")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateParameters(ctx, r)
	case r5.Patient:
		impl, ok := w.Concrete.(PatientCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Patient")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePatient(ctx, r)
	case r5.PaymentNotice:
		impl, ok := w.Concrete.(PaymentNoticeCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for PaymentNotice")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePaymentNotice(ctx, r)
	case r5.PaymentReconciliation:
		impl, ok := w.Concrete.(PaymentReconciliationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for PaymentReconciliation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePaymentReconciliation(ctx, r)
	case r5.Permission:
		impl, ok := w.Concrete.(PermissionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Permission")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePermission(ctx, r)
	case r5.Person:
		impl, ok := w.Concrete.(PersonCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Person")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePerson(ctx, r)
	case r5.PlanDefinition:
		impl, ok := w.Concrete.(PlanDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for PlanDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePlanDefinition(ctx, r)
	case r5.Practitioner:
		impl, ok := w.Concrete.(PractitionerCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Practitioner")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePractitioner(ctx, r)
	case r5.PractitionerRole:
		impl, ok := w.Concrete.(PractitionerRoleCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for PractitionerRole")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePractitionerRole(ctx, r)
	case r5.Procedure:
		impl, ok := w.Concrete.(ProcedureCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Procedure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateProcedure(ctx, r)
	case r5.Provenance:
		impl, ok := w.Concrete.(ProvenanceCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Provenance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateProvenance(ctx, r)
	case r5.Questionnaire:
		impl, ok := w.Concrete.(QuestionnaireCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Questionnaire")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateQuestionnaire(ctx, r)
	case r5.QuestionnaireResponse:
		impl, ok := w.Concrete.(QuestionnaireResponseCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for QuestionnaireResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateQuestionnaireResponse(ctx, r)
	case r5.RegulatedAuthorization:
		impl, ok := w.Concrete.(RegulatedAuthorizationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for RegulatedAuthorization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateRegulatedAuthorization(ctx, r)
	case r5.RelatedPerson:
		impl, ok := w.Concrete.(RelatedPersonCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for RelatedPerson")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateRelatedPerson(ctx, r)
	case r5.RequestOrchestration:
		impl, ok := w.Concrete.(RequestOrchestrationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for RequestOrchestration")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateRequestOrchestration(ctx, r)
	case r5.Requirements:
		impl, ok := w.Concrete.(RequirementsCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Requirements")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateRequirements(ctx, r)
	case r5.ResearchStudy:
		impl, ok := w.Concrete.(ResearchStudyCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ResearchStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateResearchStudy(ctx, r)
	case r5.ResearchSubject:
		impl, ok := w.Concrete.(ResearchSubjectCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ResearchSubject")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateResearchSubject(ctx, r)
	case r5.RiskAssessment:
		impl, ok := w.Concrete.(RiskAssessmentCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for RiskAssessment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateRiskAssessment(ctx, r)
	case r5.Schedule:
		impl, ok := w.Concrete.(ScheduleCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Schedule")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSchedule(ctx, r)
	case r5.SearchParameter:
		impl, ok := w.Concrete.(SearchParameterCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for SearchParameter")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSearchParameter(ctx, r)
	case r5.ServiceRequest:
		impl, ok := w.Concrete.(ServiceRequestCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ServiceRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateServiceRequest(ctx, r)
	case r5.Slot:
		impl, ok := w.Concrete.(SlotCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Slot")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSlot(ctx, r)
	case r5.Specimen:
		impl, ok := w.Concrete.(SpecimenCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Specimen")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSpecimen(ctx, r)
	case r5.SpecimenDefinition:
		impl, ok := w.Concrete.(SpecimenDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for SpecimenDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSpecimenDefinition(ctx, r)
	case r5.StructureDefinition:
		impl, ok := w.Concrete.(StructureDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for StructureDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateStructureDefinition(ctx, r)
	case r5.StructureMap:
		impl, ok := w.Concrete.(StructureMapCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for StructureMap")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateStructureMap(ctx, r)
	case r5.Subscription:
		impl, ok := w.Concrete.(SubscriptionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Subscription")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubscription(ctx, r)
	case r5.SubscriptionStatus:
		impl, ok := w.Concrete.(SubscriptionStatusCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for SubscriptionStatus")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubscriptionStatus(ctx, r)
	case r5.SubscriptionTopic:
		impl, ok := w.Concrete.(SubscriptionTopicCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for SubscriptionTopic")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubscriptionTopic(ctx, r)
	case r5.Substance:
		impl, ok := w.Concrete.(SubstanceCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Substance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstance(ctx, r)
	case r5.SubstanceDefinition:
		impl, ok := w.Concrete.(SubstanceDefinitionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for SubstanceDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstanceDefinition(ctx, r)
	case r5.SubstanceNucleicAcid:
		impl, ok := w.Concrete.(SubstanceNucleicAcidCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for SubstanceNucleicAcid")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstanceNucleicAcid(ctx, r)
	case r5.SubstancePolymer:
		impl, ok := w.Concrete.(SubstancePolymerCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for SubstancePolymer")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstancePolymer(ctx, r)
	case r5.SubstanceProtein:
		impl, ok := w.Concrete.(SubstanceProteinCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for SubstanceProtein")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstanceProtein(ctx, r)
	case r5.SubstanceReferenceInformation:
		impl, ok := w.Concrete.(SubstanceReferenceInformationCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for SubstanceReferenceInformation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstanceReferenceInformation(ctx, r)
	case r5.SubstanceSourceMaterial:
		impl, ok := w.Concrete.(SubstanceSourceMaterialCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for SubstanceSourceMaterial")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstanceSourceMaterial(ctx, r)
	case r5.SupplyDelivery:
		impl, ok := w.Concrete.(SupplyDeliveryCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for SupplyDelivery")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSupplyDelivery(ctx, r)
	case r5.SupplyRequest:
		impl, ok := w.Concrete.(SupplyRequestCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for SupplyRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSupplyRequest(ctx, r)
	case r5.Task:
		impl, ok := w.Concrete.(TaskCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Task")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateTask(ctx, r)
	case r5.TerminologyCapabilities:
		impl, ok := w.Concrete.(TerminologyCapabilitiesCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for TerminologyCapabilities")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateTerminologyCapabilities(ctx, r)
	case r5.TestPlan:
		impl, ok := w.Concrete.(TestPlanCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for TestPlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateTestPlan(ctx, r)
	case r5.TestReport:
		impl, ok := w.Concrete.(TestReportCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for TestReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateTestReport(ctx, r)
	case r5.TestScript:
		impl, ok := w.Concrete.(TestScriptCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for TestScript")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateTestScript(ctx, r)
	case r5.Transport:
		impl, ok := w.Concrete.(TransportCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for Transport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateTransport(ctx, r)
	case r5.ValueSet:
		impl, ok := w.Concrete.(ValueSetCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for ValueSet")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateValueSet(ctx, r)
	case r5.VerificationResult:
		impl, ok := w.Concrete.(VerificationResultCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for VerificationResult")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateVerificationResult(ctx, r)
	case r5.VisionPrescription:
		impl, ok := w.Concrete.(VisionPrescriptionCreate)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("create not implemented for VisionPrescription")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateVisionPrescription(ctx, r)
	default:
		return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("invalid resource type: " + resource.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
}
func (w Generic) Read(ctx context.Context, resourceType string, id string) (model.Resource, error) {
	g, ok := w.Concrete.(capabilities.GenericRead)
	if ok {
		// shortcut for the case that the underlying implementation already implements the generic API
		return g.Read(ctx, resourceType, id)
	}
	switch resourceType {
	case "Account":
		impl, ok := w.Concrete.(AccountRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Account")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadAccount(ctx, id)
	case "ActivityDefinition":
		impl, ok := w.Concrete.(ActivityDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ActivityDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadActivityDefinition(ctx, id)
	case "ActorDefinition":
		impl, ok := w.Concrete.(ActorDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ActorDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadActorDefinition(ctx, id)
	case "AdministrableProductDefinition":
		impl, ok := w.Concrete.(AdministrableProductDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for AdministrableProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadAdministrableProductDefinition(ctx, id)
	case "AdverseEvent":
		impl, ok := w.Concrete.(AdverseEventRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for AdverseEvent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadAdverseEvent(ctx, id)
	case "AllergyIntolerance":
		impl, ok := w.Concrete.(AllergyIntoleranceRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for AllergyIntolerance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadAllergyIntolerance(ctx, id)
	case "Appointment":
		impl, ok := w.Concrete.(AppointmentRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Appointment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadAppointment(ctx, id)
	case "AppointmentResponse":
		impl, ok := w.Concrete.(AppointmentResponseRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for AppointmentResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadAppointmentResponse(ctx, id)
	case "ArtifactAssessment":
		impl, ok := w.Concrete.(ArtifactAssessmentRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ArtifactAssessment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadArtifactAssessment(ctx, id)
	case "AuditEvent":
		impl, ok := w.Concrete.(AuditEventRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for AuditEvent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadAuditEvent(ctx, id)
	case "Basic":
		impl, ok := w.Concrete.(BasicRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Basic")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadBasic(ctx, id)
	case "Binary":
		impl, ok := w.Concrete.(BinaryRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Binary")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadBinary(ctx, id)
	case "BiologicallyDerivedProduct":
		impl, ok := w.Concrete.(BiologicallyDerivedProductRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for BiologicallyDerivedProduct")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadBiologicallyDerivedProduct(ctx, id)
	case "BiologicallyDerivedProductDispense":
		impl, ok := w.Concrete.(BiologicallyDerivedProductDispenseRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for BiologicallyDerivedProductDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadBiologicallyDerivedProductDispense(ctx, id)
	case "BodyStructure":
		impl, ok := w.Concrete.(BodyStructureRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for BodyStructure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadBodyStructure(ctx, id)
	case "Bundle":
		impl, ok := w.Concrete.(BundleRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Bundle")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadBundle(ctx, id)
	case "CapabilityStatement":
		impl, ok := w.Concrete.(CapabilityStatementRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for CapabilityStatement")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCapabilityStatement(ctx, id)
	case "CarePlan":
		impl, ok := w.Concrete.(CarePlanRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for CarePlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCarePlan(ctx, id)
	case "CareTeam":
		impl, ok := w.Concrete.(CareTeamRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for CareTeam")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCareTeam(ctx, id)
	case "ChargeItem":
		impl, ok := w.Concrete.(ChargeItemRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ChargeItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadChargeItem(ctx, id)
	case "ChargeItemDefinition":
		impl, ok := w.Concrete.(ChargeItemDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ChargeItemDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadChargeItemDefinition(ctx, id)
	case "Citation":
		impl, ok := w.Concrete.(CitationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Citation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCitation(ctx, id)
	case "Claim":
		impl, ok := w.Concrete.(ClaimRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Claim")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadClaim(ctx, id)
	case "ClaimResponse":
		impl, ok := w.Concrete.(ClaimResponseRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ClaimResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadClaimResponse(ctx, id)
	case "ClinicalImpression":
		impl, ok := w.Concrete.(ClinicalImpressionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ClinicalImpression")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadClinicalImpression(ctx, id)
	case "ClinicalUseDefinition":
		impl, ok := w.Concrete.(ClinicalUseDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ClinicalUseDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadClinicalUseDefinition(ctx, id)
	case "CodeSystem":
		impl, ok := w.Concrete.(CodeSystemRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for CodeSystem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCodeSystem(ctx, id)
	case "Communication":
		impl, ok := w.Concrete.(CommunicationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Communication")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCommunication(ctx, id)
	case "CommunicationRequest":
		impl, ok := w.Concrete.(CommunicationRequestRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for CommunicationRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCommunicationRequest(ctx, id)
	case "CompartmentDefinition":
		impl, ok := w.Concrete.(CompartmentDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for CompartmentDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCompartmentDefinition(ctx, id)
	case "Composition":
		impl, ok := w.Concrete.(CompositionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Composition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadComposition(ctx, id)
	case "ConceptMap":
		impl, ok := w.Concrete.(ConceptMapRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ConceptMap")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadConceptMap(ctx, id)
	case "Condition":
		impl, ok := w.Concrete.(ConditionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Condition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCondition(ctx, id)
	case "ConditionDefinition":
		impl, ok := w.Concrete.(ConditionDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ConditionDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadConditionDefinition(ctx, id)
	case "Consent":
		impl, ok := w.Concrete.(ConsentRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Consent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadConsent(ctx, id)
	case "Contract":
		impl, ok := w.Concrete.(ContractRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Contract")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadContract(ctx, id)
	case "Coverage":
		impl, ok := w.Concrete.(CoverageRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Coverage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCoverage(ctx, id)
	case "CoverageEligibilityRequest":
		impl, ok := w.Concrete.(CoverageEligibilityRequestRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for CoverageEligibilityRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCoverageEligibilityRequest(ctx, id)
	case "CoverageEligibilityResponse":
		impl, ok := w.Concrete.(CoverageEligibilityResponseRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for CoverageEligibilityResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCoverageEligibilityResponse(ctx, id)
	case "DetectedIssue":
		impl, ok := w.Concrete.(DetectedIssueRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for DetectedIssue")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDetectedIssue(ctx, id)
	case "Device":
		impl, ok := w.Concrete.(DeviceRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Device")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDevice(ctx, id)
	case "DeviceAssociation":
		impl, ok := w.Concrete.(DeviceAssociationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for DeviceAssociation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDeviceAssociation(ctx, id)
	case "DeviceDefinition":
		impl, ok := w.Concrete.(DeviceDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for DeviceDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDeviceDefinition(ctx, id)
	case "DeviceDispense":
		impl, ok := w.Concrete.(DeviceDispenseRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for DeviceDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDeviceDispense(ctx, id)
	case "DeviceMetric":
		impl, ok := w.Concrete.(DeviceMetricRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for DeviceMetric")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDeviceMetric(ctx, id)
	case "DeviceRequest":
		impl, ok := w.Concrete.(DeviceRequestRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for DeviceRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDeviceRequest(ctx, id)
	case "DeviceUsage":
		impl, ok := w.Concrete.(DeviceUsageRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for DeviceUsage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDeviceUsage(ctx, id)
	case "DiagnosticReport":
		impl, ok := w.Concrete.(DiagnosticReportRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for DiagnosticReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDiagnosticReport(ctx, id)
	case "DocumentReference":
		impl, ok := w.Concrete.(DocumentReferenceRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for DocumentReference")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDocumentReference(ctx, id)
	case "Encounter":
		impl, ok := w.Concrete.(EncounterRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Encounter")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEncounter(ctx, id)
	case "EncounterHistory":
		impl, ok := w.Concrete.(EncounterHistoryRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for EncounterHistory")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEncounterHistory(ctx, id)
	case "Endpoint":
		impl, ok := w.Concrete.(EndpointRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Endpoint")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEndpoint(ctx, id)
	case "EnrollmentRequest":
		impl, ok := w.Concrete.(EnrollmentRequestRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for EnrollmentRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEnrollmentRequest(ctx, id)
	case "EnrollmentResponse":
		impl, ok := w.Concrete.(EnrollmentResponseRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for EnrollmentResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEnrollmentResponse(ctx, id)
	case "EpisodeOfCare":
		impl, ok := w.Concrete.(EpisodeOfCareRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for EpisodeOfCare")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEpisodeOfCare(ctx, id)
	case "EventDefinition":
		impl, ok := w.Concrete.(EventDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for EventDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEventDefinition(ctx, id)
	case "Evidence":
		impl, ok := w.Concrete.(EvidenceRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Evidence")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEvidence(ctx, id)
	case "EvidenceReport":
		impl, ok := w.Concrete.(EvidenceReportRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for EvidenceReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEvidenceReport(ctx, id)
	case "EvidenceVariable":
		impl, ok := w.Concrete.(EvidenceVariableRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for EvidenceVariable")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEvidenceVariable(ctx, id)
	case "ExampleScenario":
		impl, ok := w.Concrete.(ExampleScenarioRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ExampleScenario")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadExampleScenario(ctx, id)
	case "ExplanationOfBenefit":
		impl, ok := w.Concrete.(ExplanationOfBenefitRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ExplanationOfBenefit")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadExplanationOfBenefit(ctx, id)
	case "FamilyMemberHistory":
		impl, ok := w.Concrete.(FamilyMemberHistoryRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for FamilyMemberHistory")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadFamilyMemberHistory(ctx, id)
	case "Flag":
		impl, ok := w.Concrete.(FlagRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Flag")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadFlag(ctx, id)
	case "FormularyItem":
		impl, ok := w.Concrete.(FormularyItemRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for FormularyItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadFormularyItem(ctx, id)
	case "GenomicStudy":
		impl, ok := w.Concrete.(GenomicStudyRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for GenomicStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadGenomicStudy(ctx, id)
	case "Goal":
		impl, ok := w.Concrete.(GoalRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Goal")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadGoal(ctx, id)
	case "GraphDefinition":
		impl, ok := w.Concrete.(GraphDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for GraphDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadGraphDefinition(ctx, id)
	case "Group":
		impl, ok := w.Concrete.(GroupRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Group")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadGroup(ctx, id)
	case "GuidanceResponse":
		impl, ok := w.Concrete.(GuidanceResponseRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for GuidanceResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadGuidanceResponse(ctx, id)
	case "HealthcareService":
		impl, ok := w.Concrete.(HealthcareServiceRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for HealthcareService")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadHealthcareService(ctx, id)
	case "ImagingSelection":
		impl, ok := w.Concrete.(ImagingSelectionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ImagingSelection")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadImagingSelection(ctx, id)
	case "ImagingStudy":
		impl, ok := w.Concrete.(ImagingStudyRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ImagingStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadImagingStudy(ctx, id)
	case "Immunization":
		impl, ok := w.Concrete.(ImmunizationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Immunization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadImmunization(ctx, id)
	case "ImmunizationEvaluation":
		impl, ok := w.Concrete.(ImmunizationEvaluationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ImmunizationEvaluation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadImmunizationEvaluation(ctx, id)
	case "ImmunizationRecommendation":
		impl, ok := w.Concrete.(ImmunizationRecommendationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ImmunizationRecommendation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadImmunizationRecommendation(ctx, id)
	case "ImplementationGuide":
		impl, ok := w.Concrete.(ImplementationGuideRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ImplementationGuide")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadImplementationGuide(ctx, id)
	case "Ingredient":
		impl, ok := w.Concrete.(IngredientRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Ingredient")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadIngredient(ctx, id)
	case "InsurancePlan":
		impl, ok := w.Concrete.(InsurancePlanRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for InsurancePlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadInsurancePlan(ctx, id)
	case "InventoryItem":
		impl, ok := w.Concrete.(InventoryItemRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for InventoryItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadInventoryItem(ctx, id)
	case "InventoryReport":
		impl, ok := w.Concrete.(InventoryReportRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for InventoryReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadInventoryReport(ctx, id)
	case "Invoice":
		impl, ok := w.Concrete.(InvoiceRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Invoice")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadInvoice(ctx, id)
	case "Library":
		impl, ok := w.Concrete.(LibraryRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Library")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadLibrary(ctx, id)
	case "Linkage":
		impl, ok := w.Concrete.(LinkageRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Linkage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadLinkage(ctx, id)
	case "List":
		impl, ok := w.Concrete.(ListRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for List")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadList(ctx, id)
	case "Location":
		impl, ok := w.Concrete.(LocationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Location")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadLocation(ctx, id)
	case "ManufacturedItemDefinition":
		impl, ok := w.Concrete.(ManufacturedItemDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ManufacturedItemDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadManufacturedItemDefinition(ctx, id)
	case "Measure":
		impl, ok := w.Concrete.(MeasureRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Measure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMeasure(ctx, id)
	case "MeasureReport":
		impl, ok := w.Concrete.(MeasureReportRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for MeasureReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMeasureReport(ctx, id)
	case "Medication":
		impl, ok := w.Concrete.(MedicationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Medication")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedication(ctx, id)
	case "MedicationAdministration":
		impl, ok := w.Concrete.(MedicationAdministrationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for MedicationAdministration")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicationAdministration(ctx, id)
	case "MedicationDispense":
		impl, ok := w.Concrete.(MedicationDispenseRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for MedicationDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicationDispense(ctx, id)
	case "MedicationKnowledge":
		impl, ok := w.Concrete.(MedicationKnowledgeRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for MedicationKnowledge")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicationKnowledge(ctx, id)
	case "MedicationRequest":
		impl, ok := w.Concrete.(MedicationRequestRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for MedicationRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicationRequest(ctx, id)
	case "MedicationStatement":
		impl, ok := w.Concrete.(MedicationStatementRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for MedicationStatement")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicationStatement(ctx, id)
	case "MedicinalProductDefinition":
		impl, ok := w.Concrete.(MedicinalProductDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for MedicinalProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicinalProductDefinition(ctx, id)
	case "MessageDefinition":
		impl, ok := w.Concrete.(MessageDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for MessageDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMessageDefinition(ctx, id)
	case "MessageHeader":
		impl, ok := w.Concrete.(MessageHeaderRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for MessageHeader")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMessageHeader(ctx, id)
	case "MolecularSequence":
		impl, ok := w.Concrete.(MolecularSequenceRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for MolecularSequence")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMolecularSequence(ctx, id)
	case "NamingSystem":
		impl, ok := w.Concrete.(NamingSystemRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for NamingSystem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadNamingSystem(ctx, id)
	case "NutritionIntake":
		impl, ok := w.Concrete.(NutritionIntakeRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for NutritionIntake")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadNutritionIntake(ctx, id)
	case "NutritionOrder":
		impl, ok := w.Concrete.(NutritionOrderRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for NutritionOrder")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadNutritionOrder(ctx, id)
	case "NutritionProduct":
		impl, ok := w.Concrete.(NutritionProductRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for NutritionProduct")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadNutritionProduct(ctx, id)
	case "Observation":
		impl, ok := w.Concrete.(ObservationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Observation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadObservation(ctx, id)
	case "ObservationDefinition":
		impl, ok := w.Concrete.(ObservationDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ObservationDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadObservationDefinition(ctx, id)
	case "OperationDefinition":
		impl, ok := w.Concrete.(OperationDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for OperationDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadOperationDefinition(ctx, id)
	case "OperationOutcome":
		impl, ok := w.Concrete.(OperationOutcomeRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for OperationOutcome")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadOperationOutcome(ctx, id)
	case "Organization":
		impl, ok := w.Concrete.(OrganizationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Organization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadOrganization(ctx, id)
	case "OrganizationAffiliation":
		impl, ok := w.Concrete.(OrganizationAffiliationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for OrganizationAffiliation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadOrganizationAffiliation(ctx, id)
	case "PackagedProductDefinition":
		impl, ok := w.Concrete.(PackagedProductDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for PackagedProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPackagedProductDefinition(ctx, id)
	case "Parameters":
		impl, ok := w.Concrete.(ParametersRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Parameters")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadParameters(ctx, id)
	case "Patient":
		impl, ok := w.Concrete.(PatientRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Patient")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPatient(ctx, id)
	case "PaymentNotice":
		impl, ok := w.Concrete.(PaymentNoticeRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for PaymentNotice")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPaymentNotice(ctx, id)
	case "PaymentReconciliation":
		impl, ok := w.Concrete.(PaymentReconciliationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for PaymentReconciliation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPaymentReconciliation(ctx, id)
	case "Permission":
		impl, ok := w.Concrete.(PermissionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Permission")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPermission(ctx, id)
	case "Person":
		impl, ok := w.Concrete.(PersonRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Person")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPerson(ctx, id)
	case "PlanDefinition":
		impl, ok := w.Concrete.(PlanDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for PlanDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPlanDefinition(ctx, id)
	case "Practitioner":
		impl, ok := w.Concrete.(PractitionerRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Practitioner")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPractitioner(ctx, id)
	case "PractitionerRole":
		impl, ok := w.Concrete.(PractitionerRoleRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for PractitionerRole")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPractitionerRole(ctx, id)
	case "Procedure":
		impl, ok := w.Concrete.(ProcedureRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Procedure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadProcedure(ctx, id)
	case "Provenance":
		impl, ok := w.Concrete.(ProvenanceRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Provenance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadProvenance(ctx, id)
	case "Questionnaire":
		impl, ok := w.Concrete.(QuestionnaireRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Questionnaire")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadQuestionnaire(ctx, id)
	case "QuestionnaireResponse":
		impl, ok := w.Concrete.(QuestionnaireResponseRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for QuestionnaireResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadQuestionnaireResponse(ctx, id)
	case "RegulatedAuthorization":
		impl, ok := w.Concrete.(RegulatedAuthorizationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for RegulatedAuthorization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadRegulatedAuthorization(ctx, id)
	case "RelatedPerson":
		impl, ok := w.Concrete.(RelatedPersonRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for RelatedPerson")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadRelatedPerson(ctx, id)
	case "RequestOrchestration":
		impl, ok := w.Concrete.(RequestOrchestrationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for RequestOrchestration")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadRequestOrchestration(ctx, id)
	case "Requirements":
		impl, ok := w.Concrete.(RequirementsRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Requirements")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadRequirements(ctx, id)
	case "ResearchStudy":
		impl, ok := w.Concrete.(ResearchStudyRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ResearchStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadResearchStudy(ctx, id)
	case "ResearchSubject":
		impl, ok := w.Concrete.(ResearchSubjectRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ResearchSubject")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadResearchSubject(ctx, id)
	case "RiskAssessment":
		impl, ok := w.Concrete.(RiskAssessmentRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for RiskAssessment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadRiskAssessment(ctx, id)
	case "Schedule":
		impl, ok := w.Concrete.(ScheduleRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Schedule")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSchedule(ctx, id)
	case "SearchParameter":
		impl, ok := w.Concrete.(SearchParameterRead)
		if ok {
			return impl.ReadSearchParameter(ctx, id)
		}
		// Fallback: gather SearchParameter from SearchCapabilities methods if ReadSearchParameter not implemented
		// Get base URL from CapabilityStatement for canonical references
		capabilityStatement, err := w.Concrete.CapabilityBase(ctx)
		if err != nil {
			return nil, err
		}
		var baseUrl string
		if capabilityStatement.Implementation != nil && capabilityStatement.Implementation.Url != nil && capabilityStatement.Implementation.Url.Value != nil {
			baseUrl = *capabilityStatement.Implementation.Url.Value
		}
		searchParameters, err := searchParameters(ctx, w.Concrete, baseUrl)
		if err != nil {
			return nil, err
		}
		searchParam, exists := searchParameters[id]
		if exists {
			return searchParam, nil
		}
		return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-found")},
			Diagnostics: &r5.String{Value: ptr.To("SearchParameter with ID " + id + " not found")},
			Severity:    r5.Code{Value: ptr.To("error")},
		}}}
	case "ServiceRequest":
		impl, ok := w.Concrete.(ServiceRequestRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ServiceRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadServiceRequest(ctx, id)
	case "Slot":
		impl, ok := w.Concrete.(SlotRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Slot")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSlot(ctx, id)
	case "Specimen":
		impl, ok := w.Concrete.(SpecimenRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Specimen")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSpecimen(ctx, id)
	case "SpecimenDefinition":
		impl, ok := w.Concrete.(SpecimenDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for SpecimenDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSpecimenDefinition(ctx, id)
	case "StructureDefinition":
		impl, ok := w.Concrete.(StructureDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for StructureDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadStructureDefinition(ctx, id)
	case "StructureMap":
		impl, ok := w.Concrete.(StructureMapRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for StructureMap")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadStructureMap(ctx, id)
	case "Subscription":
		impl, ok := w.Concrete.(SubscriptionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Subscription")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubscription(ctx, id)
	case "SubscriptionStatus":
		impl, ok := w.Concrete.(SubscriptionStatusRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for SubscriptionStatus")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubscriptionStatus(ctx, id)
	case "SubscriptionTopic":
		impl, ok := w.Concrete.(SubscriptionTopicRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for SubscriptionTopic")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubscriptionTopic(ctx, id)
	case "Substance":
		impl, ok := w.Concrete.(SubstanceRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Substance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstance(ctx, id)
	case "SubstanceDefinition":
		impl, ok := w.Concrete.(SubstanceDefinitionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for SubstanceDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstanceDefinition(ctx, id)
	case "SubstanceNucleicAcid":
		impl, ok := w.Concrete.(SubstanceNucleicAcidRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for SubstanceNucleicAcid")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstanceNucleicAcid(ctx, id)
	case "SubstancePolymer":
		impl, ok := w.Concrete.(SubstancePolymerRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for SubstancePolymer")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstancePolymer(ctx, id)
	case "SubstanceProtein":
		impl, ok := w.Concrete.(SubstanceProteinRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for SubstanceProtein")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstanceProtein(ctx, id)
	case "SubstanceReferenceInformation":
		impl, ok := w.Concrete.(SubstanceReferenceInformationRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for SubstanceReferenceInformation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstanceReferenceInformation(ctx, id)
	case "SubstanceSourceMaterial":
		impl, ok := w.Concrete.(SubstanceSourceMaterialRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for SubstanceSourceMaterial")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstanceSourceMaterial(ctx, id)
	case "SupplyDelivery":
		impl, ok := w.Concrete.(SupplyDeliveryRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for SupplyDelivery")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSupplyDelivery(ctx, id)
	case "SupplyRequest":
		impl, ok := w.Concrete.(SupplyRequestRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for SupplyRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSupplyRequest(ctx, id)
	case "Task":
		impl, ok := w.Concrete.(TaskRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Task")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadTask(ctx, id)
	case "TerminologyCapabilities":
		impl, ok := w.Concrete.(TerminologyCapabilitiesRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for TerminologyCapabilities")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadTerminologyCapabilities(ctx, id)
	case "TestPlan":
		impl, ok := w.Concrete.(TestPlanRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for TestPlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadTestPlan(ctx, id)
	case "TestReport":
		impl, ok := w.Concrete.(TestReportRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for TestReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadTestReport(ctx, id)
	case "TestScript":
		impl, ok := w.Concrete.(TestScriptRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for TestScript")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadTestScript(ctx, id)
	case "Transport":
		impl, ok := w.Concrete.(TransportRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for Transport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadTransport(ctx, id)
	case "ValueSet":
		impl, ok := w.Concrete.(ValueSetRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for ValueSet")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadValueSet(ctx, id)
	case "VerificationResult":
		impl, ok := w.Concrete.(VerificationResultRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for VerificationResult")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadVerificationResult(ctx, id)
	case "VisionPrescription":
		impl, ok := w.Concrete.(VisionPrescriptionRead)
		if !ok {
			return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("read not implemented for VisionPrescription")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadVisionPrescription(ctx, id)
	default:
		return nil, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("invalid resource type: " + resourceType)},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
}
func (w Generic) Update(ctx context.Context, resource model.Resource) (update.Result[model.Resource], error) {
	g, ok := w.Concrete.(capabilities.GenericUpdate)
	if ok {
		// shortcut for the case that the underlying implementation already implements the generic API
		return g.Update(ctx, resource)
	}
	switch r := resource.(type) {
	case r5.Account:
		impl, ok := w.Concrete.(AccountUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Account")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateAccount(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ActivityDefinition:
		impl, ok := w.Concrete.(ActivityDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ActivityDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateActivityDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ActorDefinition:
		impl, ok := w.Concrete.(ActorDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ActorDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateActorDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.AdministrableProductDefinition:
		impl, ok := w.Concrete.(AdministrableProductDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for AdministrableProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateAdministrableProductDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.AdverseEvent:
		impl, ok := w.Concrete.(AdverseEventUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for AdverseEvent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateAdverseEvent(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.AllergyIntolerance:
		impl, ok := w.Concrete.(AllergyIntoleranceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for AllergyIntolerance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateAllergyIntolerance(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Appointment:
		impl, ok := w.Concrete.(AppointmentUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Appointment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateAppointment(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.AppointmentResponse:
		impl, ok := w.Concrete.(AppointmentResponseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for AppointmentResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateAppointmentResponse(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ArtifactAssessment:
		impl, ok := w.Concrete.(ArtifactAssessmentUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ArtifactAssessment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateArtifactAssessment(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.AuditEvent:
		impl, ok := w.Concrete.(AuditEventUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for AuditEvent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateAuditEvent(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Basic:
		impl, ok := w.Concrete.(BasicUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Basic")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateBasic(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Binary:
		impl, ok := w.Concrete.(BinaryUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Binary")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateBinary(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.BiologicallyDerivedProduct:
		impl, ok := w.Concrete.(BiologicallyDerivedProductUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for BiologicallyDerivedProduct")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateBiologicallyDerivedProduct(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.BiologicallyDerivedProductDispense:
		impl, ok := w.Concrete.(BiologicallyDerivedProductDispenseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for BiologicallyDerivedProductDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateBiologicallyDerivedProductDispense(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.BodyStructure:
		impl, ok := w.Concrete.(BodyStructureUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for BodyStructure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateBodyStructure(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Bundle:
		impl, ok := w.Concrete.(BundleUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Bundle")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateBundle(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.CapabilityStatement:
		impl, ok := w.Concrete.(CapabilityStatementUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for CapabilityStatement")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCapabilityStatement(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.CarePlan:
		impl, ok := w.Concrete.(CarePlanUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for CarePlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCarePlan(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.CareTeam:
		impl, ok := w.Concrete.(CareTeamUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for CareTeam")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCareTeam(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ChargeItem:
		impl, ok := w.Concrete.(ChargeItemUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ChargeItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateChargeItem(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ChargeItemDefinition:
		impl, ok := w.Concrete.(ChargeItemDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ChargeItemDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateChargeItemDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Citation:
		impl, ok := w.Concrete.(CitationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Citation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCitation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Claim:
		impl, ok := w.Concrete.(ClaimUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Claim")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateClaim(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ClaimResponse:
		impl, ok := w.Concrete.(ClaimResponseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ClaimResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateClaimResponse(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ClinicalImpression:
		impl, ok := w.Concrete.(ClinicalImpressionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ClinicalImpression")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateClinicalImpression(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ClinicalUseDefinition:
		impl, ok := w.Concrete.(ClinicalUseDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ClinicalUseDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateClinicalUseDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.CodeSystem:
		impl, ok := w.Concrete.(CodeSystemUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for CodeSystem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCodeSystem(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Communication:
		impl, ok := w.Concrete.(CommunicationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Communication")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCommunication(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.CommunicationRequest:
		impl, ok := w.Concrete.(CommunicationRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for CommunicationRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCommunicationRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.CompartmentDefinition:
		impl, ok := w.Concrete.(CompartmentDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for CompartmentDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCompartmentDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Composition:
		impl, ok := w.Concrete.(CompositionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Composition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateComposition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ConceptMap:
		impl, ok := w.Concrete.(ConceptMapUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ConceptMap")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateConceptMap(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Condition:
		impl, ok := w.Concrete.(ConditionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Condition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCondition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ConditionDefinition:
		impl, ok := w.Concrete.(ConditionDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ConditionDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateConditionDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Consent:
		impl, ok := w.Concrete.(ConsentUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Consent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateConsent(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Contract:
		impl, ok := w.Concrete.(ContractUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Contract")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateContract(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Coverage:
		impl, ok := w.Concrete.(CoverageUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Coverage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCoverage(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.CoverageEligibilityRequest:
		impl, ok := w.Concrete.(CoverageEligibilityRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for CoverageEligibilityRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCoverageEligibilityRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.CoverageEligibilityResponse:
		impl, ok := w.Concrete.(CoverageEligibilityResponseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for CoverageEligibilityResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCoverageEligibilityResponse(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.DetectedIssue:
		impl, ok := w.Concrete.(DetectedIssueUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for DetectedIssue")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDetectedIssue(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Device:
		impl, ok := w.Concrete.(DeviceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Device")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDevice(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.DeviceAssociation:
		impl, ok := w.Concrete.(DeviceAssociationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for DeviceAssociation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDeviceAssociation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.DeviceDefinition:
		impl, ok := w.Concrete.(DeviceDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for DeviceDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDeviceDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.DeviceDispense:
		impl, ok := w.Concrete.(DeviceDispenseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for DeviceDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDeviceDispense(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.DeviceMetric:
		impl, ok := w.Concrete.(DeviceMetricUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for DeviceMetric")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDeviceMetric(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.DeviceRequest:
		impl, ok := w.Concrete.(DeviceRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for DeviceRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDeviceRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.DeviceUsage:
		impl, ok := w.Concrete.(DeviceUsageUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for DeviceUsage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDeviceUsage(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.DiagnosticReport:
		impl, ok := w.Concrete.(DiagnosticReportUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for DiagnosticReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDiagnosticReport(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.DocumentReference:
		impl, ok := w.Concrete.(DocumentReferenceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for DocumentReference")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDocumentReference(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Encounter:
		impl, ok := w.Concrete.(EncounterUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Encounter")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEncounter(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.EncounterHistory:
		impl, ok := w.Concrete.(EncounterHistoryUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for EncounterHistory")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEncounterHistory(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Endpoint:
		impl, ok := w.Concrete.(EndpointUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Endpoint")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEndpoint(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.EnrollmentRequest:
		impl, ok := w.Concrete.(EnrollmentRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for EnrollmentRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEnrollmentRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.EnrollmentResponse:
		impl, ok := w.Concrete.(EnrollmentResponseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for EnrollmentResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEnrollmentResponse(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.EpisodeOfCare:
		impl, ok := w.Concrete.(EpisodeOfCareUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for EpisodeOfCare")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEpisodeOfCare(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.EventDefinition:
		impl, ok := w.Concrete.(EventDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for EventDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEventDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Evidence:
		impl, ok := w.Concrete.(EvidenceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Evidence")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEvidence(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.EvidenceReport:
		impl, ok := w.Concrete.(EvidenceReportUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for EvidenceReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEvidenceReport(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.EvidenceVariable:
		impl, ok := w.Concrete.(EvidenceVariableUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for EvidenceVariable")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEvidenceVariable(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ExampleScenario:
		impl, ok := w.Concrete.(ExampleScenarioUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ExampleScenario")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateExampleScenario(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ExplanationOfBenefit:
		impl, ok := w.Concrete.(ExplanationOfBenefitUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ExplanationOfBenefit")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateExplanationOfBenefit(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.FamilyMemberHistory:
		impl, ok := w.Concrete.(FamilyMemberHistoryUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for FamilyMemberHistory")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateFamilyMemberHistory(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Flag:
		impl, ok := w.Concrete.(FlagUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Flag")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateFlag(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.FormularyItem:
		impl, ok := w.Concrete.(FormularyItemUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for FormularyItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateFormularyItem(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.GenomicStudy:
		impl, ok := w.Concrete.(GenomicStudyUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for GenomicStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateGenomicStudy(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Goal:
		impl, ok := w.Concrete.(GoalUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Goal")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateGoal(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.GraphDefinition:
		impl, ok := w.Concrete.(GraphDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for GraphDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateGraphDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Group:
		impl, ok := w.Concrete.(GroupUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Group")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateGroup(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.GuidanceResponse:
		impl, ok := w.Concrete.(GuidanceResponseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for GuidanceResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateGuidanceResponse(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.HealthcareService:
		impl, ok := w.Concrete.(HealthcareServiceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for HealthcareService")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateHealthcareService(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ImagingSelection:
		impl, ok := w.Concrete.(ImagingSelectionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ImagingSelection")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateImagingSelection(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ImagingStudy:
		impl, ok := w.Concrete.(ImagingStudyUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ImagingStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateImagingStudy(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Immunization:
		impl, ok := w.Concrete.(ImmunizationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Immunization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateImmunization(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ImmunizationEvaluation:
		impl, ok := w.Concrete.(ImmunizationEvaluationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ImmunizationEvaluation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateImmunizationEvaluation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ImmunizationRecommendation:
		impl, ok := w.Concrete.(ImmunizationRecommendationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ImmunizationRecommendation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateImmunizationRecommendation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ImplementationGuide:
		impl, ok := w.Concrete.(ImplementationGuideUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ImplementationGuide")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateImplementationGuide(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Ingredient:
		impl, ok := w.Concrete.(IngredientUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Ingredient")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateIngredient(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.InsurancePlan:
		impl, ok := w.Concrete.(InsurancePlanUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for InsurancePlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateInsurancePlan(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.InventoryItem:
		impl, ok := w.Concrete.(InventoryItemUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for InventoryItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateInventoryItem(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.InventoryReport:
		impl, ok := w.Concrete.(InventoryReportUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for InventoryReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateInventoryReport(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Invoice:
		impl, ok := w.Concrete.(InvoiceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Invoice")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateInvoice(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Library:
		impl, ok := w.Concrete.(LibraryUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Library")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateLibrary(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Linkage:
		impl, ok := w.Concrete.(LinkageUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Linkage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateLinkage(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.List:
		impl, ok := w.Concrete.(ListUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for List")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateList(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Location:
		impl, ok := w.Concrete.(LocationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Location")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateLocation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ManufacturedItemDefinition:
		impl, ok := w.Concrete.(ManufacturedItemDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ManufacturedItemDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateManufacturedItemDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Measure:
		impl, ok := w.Concrete.(MeasureUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Measure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMeasure(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.MeasureReport:
		impl, ok := w.Concrete.(MeasureReportUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for MeasureReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMeasureReport(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Medication:
		impl, ok := w.Concrete.(MedicationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Medication")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedication(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.MedicationAdministration:
		impl, ok := w.Concrete.(MedicationAdministrationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for MedicationAdministration")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicationAdministration(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.MedicationDispense:
		impl, ok := w.Concrete.(MedicationDispenseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for MedicationDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicationDispense(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.MedicationKnowledge:
		impl, ok := w.Concrete.(MedicationKnowledgeUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for MedicationKnowledge")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicationKnowledge(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.MedicationRequest:
		impl, ok := w.Concrete.(MedicationRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for MedicationRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicationRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.MedicationStatement:
		impl, ok := w.Concrete.(MedicationStatementUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for MedicationStatement")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicationStatement(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.MedicinalProductDefinition:
		impl, ok := w.Concrete.(MedicinalProductDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for MedicinalProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicinalProductDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.MessageDefinition:
		impl, ok := w.Concrete.(MessageDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for MessageDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMessageDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.MessageHeader:
		impl, ok := w.Concrete.(MessageHeaderUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for MessageHeader")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMessageHeader(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.MolecularSequence:
		impl, ok := w.Concrete.(MolecularSequenceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for MolecularSequence")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMolecularSequence(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.NamingSystem:
		impl, ok := w.Concrete.(NamingSystemUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for NamingSystem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateNamingSystem(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.NutritionIntake:
		impl, ok := w.Concrete.(NutritionIntakeUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for NutritionIntake")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateNutritionIntake(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.NutritionOrder:
		impl, ok := w.Concrete.(NutritionOrderUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for NutritionOrder")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateNutritionOrder(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.NutritionProduct:
		impl, ok := w.Concrete.(NutritionProductUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for NutritionProduct")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateNutritionProduct(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Observation:
		impl, ok := w.Concrete.(ObservationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Observation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateObservation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ObservationDefinition:
		impl, ok := w.Concrete.(ObservationDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ObservationDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateObservationDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.OperationDefinition:
		impl, ok := w.Concrete.(OperationDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for OperationDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateOperationDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.OperationOutcome:
		impl, ok := w.Concrete.(OperationOutcomeUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for OperationOutcome")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateOperationOutcome(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Organization:
		impl, ok := w.Concrete.(OrganizationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Organization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateOrganization(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.OrganizationAffiliation:
		impl, ok := w.Concrete.(OrganizationAffiliationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for OrganizationAffiliation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateOrganizationAffiliation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.PackagedProductDefinition:
		impl, ok := w.Concrete.(PackagedProductDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for PackagedProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePackagedProductDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Parameters:
		impl, ok := w.Concrete.(ParametersUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Parameters")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateParameters(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Patient:
		impl, ok := w.Concrete.(PatientUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Patient")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePatient(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.PaymentNotice:
		impl, ok := w.Concrete.(PaymentNoticeUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for PaymentNotice")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePaymentNotice(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.PaymentReconciliation:
		impl, ok := w.Concrete.(PaymentReconciliationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for PaymentReconciliation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePaymentReconciliation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Permission:
		impl, ok := w.Concrete.(PermissionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Permission")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePermission(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Person:
		impl, ok := w.Concrete.(PersonUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Person")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePerson(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.PlanDefinition:
		impl, ok := w.Concrete.(PlanDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for PlanDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePlanDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Practitioner:
		impl, ok := w.Concrete.(PractitionerUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Practitioner")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePractitioner(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.PractitionerRole:
		impl, ok := w.Concrete.(PractitionerRoleUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for PractitionerRole")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePractitionerRole(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Procedure:
		impl, ok := w.Concrete.(ProcedureUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Procedure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateProcedure(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Provenance:
		impl, ok := w.Concrete.(ProvenanceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Provenance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateProvenance(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Questionnaire:
		impl, ok := w.Concrete.(QuestionnaireUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Questionnaire")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateQuestionnaire(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.QuestionnaireResponse:
		impl, ok := w.Concrete.(QuestionnaireResponseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for QuestionnaireResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateQuestionnaireResponse(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.RegulatedAuthorization:
		impl, ok := w.Concrete.(RegulatedAuthorizationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for RegulatedAuthorization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateRegulatedAuthorization(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.RelatedPerson:
		impl, ok := w.Concrete.(RelatedPersonUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for RelatedPerson")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateRelatedPerson(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.RequestOrchestration:
		impl, ok := w.Concrete.(RequestOrchestrationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for RequestOrchestration")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateRequestOrchestration(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Requirements:
		impl, ok := w.Concrete.(RequirementsUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Requirements")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateRequirements(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ResearchStudy:
		impl, ok := w.Concrete.(ResearchStudyUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ResearchStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateResearchStudy(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ResearchSubject:
		impl, ok := w.Concrete.(ResearchSubjectUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ResearchSubject")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateResearchSubject(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.RiskAssessment:
		impl, ok := w.Concrete.(RiskAssessmentUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for RiskAssessment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateRiskAssessment(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Schedule:
		impl, ok := w.Concrete.(ScheduleUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Schedule")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSchedule(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.SearchParameter:
		impl, ok := w.Concrete.(SearchParameterUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for SearchParameter")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSearchParameter(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ServiceRequest:
		impl, ok := w.Concrete.(ServiceRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ServiceRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateServiceRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Slot:
		impl, ok := w.Concrete.(SlotUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Slot")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSlot(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Specimen:
		impl, ok := w.Concrete.(SpecimenUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Specimen")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSpecimen(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.SpecimenDefinition:
		impl, ok := w.Concrete.(SpecimenDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for SpecimenDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSpecimenDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.StructureDefinition:
		impl, ok := w.Concrete.(StructureDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for StructureDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateStructureDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.StructureMap:
		impl, ok := w.Concrete.(StructureMapUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for StructureMap")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateStructureMap(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Subscription:
		impl, ok := w.Concrete.(SubscriptionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Subscription")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubscription(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.SubscriptionStatus:
		impl, ok := w.Concrete.(SubscriptionStatusUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for SubscriptionStatus")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubscriptionStatus(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.SubscriptionTopic:
		impl, ok := w.Concrete.(SubscriptionTopicUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for SubscriptionTopic")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubscriptionTopic(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Substance:
		impl, ok := w.Concrete.(SubstanceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Substance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstance(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.SubstanceDefinition:
		impl, ok := w.Concrete.(SubstanceDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for SubstanceDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstanceDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.SubstanceNucleicAcid:
		impl, ok := w.Concrete.(SubstanceNucleicAcidUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for SubstanceNucleicAcid")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstanceNucleicAcid(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.SubstancePolymer:
		impl, ok := w.Concrete.(SubstancePolymerUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for SubstancePolymer")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstancePolymer(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.SubstanceProtein:
		impl, ok := w.Concrete.(SubstanceProteinUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for SubstanceProtein")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstanceProtein(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.SubstanceReferenceInformation:
		impl, ok := w.Concrete.(SubstanceReferenceInformationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for SubstanceReferenceInformation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstanceReferenceInformation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.SubstanceSourceMaterial:
		impl, ok := w.Concrete.(SubstanceSourceMaterialUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for SubstanceSourceMaterial")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstanceSourceMaterial(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.SupplyDelivery:
		impl, ok := w.Concrete.(SupplyDeliveryUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for SupplyDelivery")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSupplyDelivery(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.SupplyRequest:
		impl, ok := w.Concrete.(SupplyRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for SupplyRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSupplyRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Task:
		impl, ok := w.Concrete.(TaskUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Task")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateTask(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.TerminologyCapabilities:
		impl, ok := w.Concrete.(TerminologyCapabilitiesUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for TerminologyCapabilities")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateTerminologyCapabilities(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.TestPlan:
		impl, ok := w.Concrete.(TestPlanUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for TestPlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateTestPlan(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.TestReport:
		impl, ok := w.Concrete.(TestReportUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for TestReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateTestReport(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.TestScript:
		impl, ok := w.Concrete.(TestScriptUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for TestScript")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateTestScript(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.Transport:
		impl, ok := w.Concrete.(TransportUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for Transport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateTransport(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.ValueSet:
		impl, ok := w.Concrete.(ValueSetUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for ValueSet")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateValueSet(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.VerificationResult:
		impl, ok := w.Concrete.(VerificationResultUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for VerificationResult")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateVerificationResult(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r5.VisionPrescription:
		impl, ok := w.Concrete.(VisionPrescriptionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("update not implemented for VisionPrescription")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateVisionPrescription(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	default:
		return update.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("invalid resource type: " + resource.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
}
func (w Generic) Delete(ctx context.Context, resourceType string, id string) error {
	g, ok := w.Concrete.(capabilities.GenericDelete)
	if ok {
		// shortcut for the case that the underlying implementation already implements the generic API
		return g.Delete(ctx, resourceType, id)
	}
	switch resourceType {
	case "Account":
		impl, ok := w.Concrete.(AccountDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Account")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteAccount(ctx, id)
	case "ActivityDefinition":
		impl, ok := w.Concrete.(ActivityDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ActivityDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteActivityDefinition(ctx, id)
	case "ActorDefinition":
		impl, ok := w.Concrete.(ActorDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ActorDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteActorDefinition(ctx, id)
	case "AdministrableProductDefinition":
		impl, ok := w.Concrete.(AdministrableProductDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for AdministrableProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteAdministrableProductDefinition(ctx, id)
	case "AdverseEvent":
		impl, ok := w.Concrete.(AdverseEventDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for AdverseEvent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteAdverseEvent(ctx, id)
	case "AllergyIntolerance":
		impl, ok := w.Concrete.(AllergyIntoleranceDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for AllergyIntolerance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteAllergyIntolerance(ctx, id)
	case "Appointment":
		impl, ok := w.Concrete.(AppointmentDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Appointment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteAppointment(ctx, id)
	case "AppointmentResponse":
		impl, ok := w.Concrete.(AppointmentResponseDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for AppointmentResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteAppointmentResponse(ctx, id)
	case "ArtifactAssessment":
		impl, ok := w.Concrete.(ArtifactAssessmentDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ArtifactAssessment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteArtifactAssessment(ctx, id)
	case "AuditEvent":
		impl, ok := w.Concrete.(AuditEventDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for AuditEvent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteAuditEvent(ctx, id)
	case "Basic":
		impl, ok := w.Concrete.(BasicDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Basic")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteBasic(ctx, id)
	case "Binary":
		impl, ok := w.Concrete.(BinaryDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Binary")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteBinary(ctx, id)
	case "BiologicallyDerivedProduct":
		impl, ok := w.Concrete.(BiologicallyDerivedProductDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for BiologicallyDerivedProduct")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteBiologicallyDerivedProduct(ctx, id)
	case "BiologicallyDerivedProductDispense":
		impl, ok := w.Concrete.(BiologicallyDerivedProductDispenseDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for BiologicallyDerivedProductDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteBiologicallyDerivedProductDispense(ctx, id)
	case "BodyStructure":
		impl, ok := w.Concrete.(BodyStructureDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for BodyStructure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteBodyStructure(ctx, id)
	case "Bundle":
		impl, ok := w.Concrete.(BundleDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Bundle")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteBundle(ctx, id)
	case "CapabilityStatement":
		impl, ok := w.Concrete.(CapabilityStatementDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for CapabilityStatement")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCapabilityStatement(ctx, id)
	case "CarePlan":
		impl, ok := w.Concrete.(CarePlanDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for CarePlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCarePlan(ctx, id)
	case "CareTeam":
		impl, ok := w.Concrete.(CareTeamDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for CareTeam")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCareTeam(ctx, id)
	case "ChargeItem":
		impl, ok := w.Concrete.(ChargeItemDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ChargeItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteChargeItem(ctx, id)
	case "ChargeItemDefinition":
		impl, ok := w.Concrete.(ChargeItemDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ChargeItemDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteChargeItemDefinition(ctx, id)
	case "Citation":
		impl, ok := w.Concrete.(CitationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Citation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCitation(ctx, id)
	case "Claim":
		impl, ok := w.Concrete.(ClaimDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Claim")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteClaim(ctx, id)
	case "ClaimResponse":
		impl, ok := w.Concrete.(ClaimResponseDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ClaimResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteClaimResponse(ctx, id)
	case "ClinicalImpression":
		impl, ok := w.Concrete.(ClinicalImpressionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ClinicalImpression")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteClinicalImpression(ctx, id)
	case "ClinicalUseDefinition":
		impl, ok := w.Concrete.(ClinicalUseDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ClinicalUseDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteClinicalUseDefinition(ctx, id)
	case "CodeSystem":
		impl, ok := w.Concrete.(CodeSystemDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for CodeSystem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCodeSystem(ctx, id)
	case "Communication":
		impl, ok := w.Concrete.(CommunicationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Communication")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCommunication(ctx, id)
	case "CommunicationRequest":
		impl, ok := w.Concrete.(CommunicationRequestDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for CommunicationRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCommunicationRequest(ctx, id)
	case "CompartmentDefinition":
		impl, ok := w.Concrete.(CompartmentDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for CompartmentDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCompartmentDefinition(ctx, id)
	case "Composition":
		impl, ok := w.Concrete.(CompositionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Composition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteComposition(ctx, id)
	case "ConceptMap":
		impl, ok := w.Concrete.(ConceptMapDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ConceptMap")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteConceptMap(ctx, id)
	case "Condition":
		impl, ok := w.Concrete.(ConditionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Condition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCondition(ctx, id)
	case "ConditionDefinition":
		impl, ok := w.Concrete.(ConditionDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ConditionDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteConditionDefinition(ctx, id)
	case "Consent":
		impl, ok := w.Concrete.(ConsentDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Consent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteConsent(ctx, id)
	case "Contract":
		impl, ok := w.Concrete.(ContractDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Contract")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteContract(ctx, id)
	case "Coverage":
		impl, ok := w.Concrete.(CoverageDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Coverage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCoverage(ctx, id)
	case "CoverageEligibilityRequest":
		impl, ok := w.Concrete.(CoverageEligibilityRequestDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for CoverageEligibilityRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCoverageEligibilityRequest(ctx, id)
	case "CoverageEligibilityResponse":
		impl, ok := w.Concrete.(CoverageEligibilityResponseDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for CoverageEligibilityResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCoverageEligibilityResponse(ctx, id)
	case "DetectedIssue":
		impl, ok := w.Concrete.(DetectedIssueDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for DetectedIssue")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDetectedIssue(ctx, id)
	case "Device":
		impl, ok := w.Concrete.(DeviceDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Device")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDevice(ctx, id)
	case "DeviceAssociation":
		impl, ok := w.Concrete.(DeviceAssociationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for DeviceAssociation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDeviceAssociation(ctx, id)
	case "DeviceDefinition":
		impl, ok := w.Concrete.(DeviceDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for DeviceDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDeviceDefinition(ctx, id)
	case "DeviceDispense":
		impl, ok := w.Concrete.(DeviceDispenseDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for DeviceDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDeviceDispense(ctx, id)
	case "DeviceMetric":
		impl, ok := w.Concrete.(DeviceMetricDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for DeviceMetric")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDeviceMetric(ctx, id)
	case "DeviceRequest":
		impl, ok := w.Concrete.(DeviceRequestDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for DeviceRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDeviceRequest(ctx, id)
	case "DeviceUsage":
		impl, ok := w.Concrete.(DeviceUsageDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for DeviceUsage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDeviceUsage(ctx, id)
	case "DiagnosticReport":
		impl, ok := w.Concrete.(DiagnosticReportDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for DiagnosticReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDiagnosticReport(ctx, id)
	case "DocumentReference":
		impl, ok := w.Concrete.(DocumentReferenceDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for DocumentReference")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDocumentReference(ctx, id)
	case "Encounter":
		impl, ok := w.Concrete.(EncounterDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Encounter")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEncounter(ctx, id)
	case "EncounterHistory":
		impl, ok := w.Concrete.(EncounterHistoryDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for EncounterHistory")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEncounterHistory(ctx, id)
	case "Endpoint":
		impl, ok := w.Concrete.(EndpointDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Endpoint")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEndpoint(ctx, id)
	case "EnrollmentRequest":
		impl, ok := w.Concrete.(EnrollmentRequestDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for EnrollmentRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEnrollmentRequest(ctx, id)
	case "EnrollmentResponse":
		impl, ok := w.Concrete.(EnrollmentResponseDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for EnrollmentResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEnrollmentResponse(ctx, id)
	case "EpisodeOfCare":
		impl, ok := w.Concrete.(EpisodeOfCareDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for EpisodeOfCare")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEpisodeOfCare(ctx, id)
	case "EventDefinition":
		impl, ok := w.Concrete.(EventDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for EventDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEventDefinition(ctx, id)
	case "Evidence":
		impl, ok := w.Concrete.(EvidenceDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Evidence")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEvidence(ctx, id)
	case "EvidenceReport":
		impl, ok := w.Concrete.(EvidenceReportDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for EvidenceReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEvidenceReport(ctx, id)
	case "EvidenceVariable":
		impl, ok := w.Concrete.(EvidenceVariableDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for EvidenceVariable")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEvidenceVariable(ctx, id)
	case "ExampleScenario":
		impl, ok := w.Concrete.(ExampleScenarioDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ExampleScenario")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteExampleScenario(ctx, id)
	case "ExplanationOfBenefit":
		impl, ok := w.Concrete.(ExplanationOfBenefitDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ExplanationOfBenefit")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteExplanationOfBenefit(ctx, id)
	case "FamilyMemberHistory":
		impl, ok := w.Concrete.(FamilyMemberHistoryDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for FamilyMemberHistory")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteFamilyMemberHistory(ctx, id)
	case "Flag":
		impl, ok := w.Concrete.(FlagDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Flag")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteFlag(ctx, id)
	case "FormularyItem":
		impl, ok := w.Concrete.(FormularyItemDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for FormularyItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteFormularyItem(ctx, id)
	case "GenomicStudy":
		impl, ok := w.Concrete.(GenomicStudyDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for GenomicStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteGenomicStudy(ctx, id)
	case "Goal":
		impl, ok := w.Concrete.(GoalDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Goal")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteGoal(ctx, id)
	case "GraphDefinition":
		impl, ok := w.Concrete.(GraphDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for GraphDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteGraphDefinition(ctx, id)
	case "Group":
		impl, ok := w.Concrete.(GroupDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Group")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteGroup(ctx, id)
	case "GuidanceResponse":
		impl, ok := w.Concrete.(GuidanceResponseDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for GuidanceResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteGuidanceResponse(ctx, id)
	case "HealthcareService":
		impl, ok := w.Concrete.(HealthcareServiceDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for HealthcareService")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteHealthcareService(ctx, id)
	case "ImagingSelection":
		impl, ok := w.Concrete.(ImagingSelectionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ImagingSelection")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteImagingSelection(ctx, id)
	case "ImagingStudy":
		impl, ok := w.Concrete.(ImagingStudyDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ImagingStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteImagingStudy(ctx, id)
	case "Immunization":
		impl, ok := w.Concrete.(ImmunizationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Immunization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteImmunization(ctx, id)
	case "ImmunizationEvaluation":
		impl, ok := w.Concrete.(ImmunizationEvaluationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ImmunizationEvaluation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteImmunizationEvaluation(ctx, id)
	case "ImmunizationRecommendation":
		impl, ok := w.Concrete.(ImmunizationRecommendationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ImmunizationRecommendation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteImmunizationRecommendation(ctx, id)
	case "ImplementationGuide":
		impl, ok := w.Concrete.(ImplementationGuideDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ImplementationGuide")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteImplementationGuide(ctx, id)
	case "Ingredient":
		impl, ok := w.Concrete.(IngredientDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Ingredient")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteIngredient(ctx, id)
	case "InsurancePlan":
		impl, ok := w.Concrete.(InsurancePlanDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for InsurancePlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteInsurancePlan(ctx, id)
	case "InventoryItem":
		impl, ok := w.Concrete.(InventoryItemDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for InventoryItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteInventoryItem(ctx, id)
	case "InventoryReport":
		impl, ok := w.Concrete.(InventoryReportDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for InventoryReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteInventoryReport(ctx, id)
	case "Invoice":
		impl, ok := w.Concrete.(InvoiceDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Invoice")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteInvoice(ctx, id)
	case "Library":
		impl, ok := w.Concrete.(LibraryDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Library")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteLibrary(ctx, id)
	case "Linkage":
		impl, ok := w.Concrete.(LinkageDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Linkage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteLinkage(ctx, id)
	case "List":
		impl, ok := w.Concrete.(ListDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for List")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteList(ctx, id)
	case "Location":
		impl, ok := w.Concrete.(LocationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Location")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteLocation(ctx, id)
	case "ManufacturedItemDefinition":
		impl, ok := w.Concrete.(ManufacturedItemDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ManufacturedItemDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteManufacturedItemDefinition(ctx, id)
	case "Measure":
		impl, ok := w.Concrete.(MeasureDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Measure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMeasure(ctx, id)
	case "MeasureReport":
		impl, ok := w.Concrete.(MeasureReportDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for MeasureReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMeasureReport(ctx, id)
	case "Medication":
		impl, ok := w.Concrete.(MedicationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Medication")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedication(ctx, id)
	case "MedicationAdministration":
		impl, ok := w.Concrete.(MedicationAdministrationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for MedicationAdministration")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicationAdministration(ctx, id)
	case "MedicationDispense":
		impl, ok := w.Concrete.(MedicationDispenseDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for MedicationDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicationDispense(ctx, id)
	case "MedicationKnowledge":
		impl, ok := w.Concrete.(MedicationKnowledgeDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for MedicationKnowledge")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicationKnowledge(ctx, id)
	case "MedicationRequest":
		impl, ok := w.Concrete.(MedicationRequestDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for MedicationRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicationRequest(ctx, id)
	case "MedicationStatement":
		impl, ok := w.Concrete.(MedicationStatementDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for MedicationStatement")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicationStatement(ctx, id)
	case "MedicinalProductDefinition":
		impl, ok := w.Concrete.(MedicinalProductDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for MedicinalProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicinalProductDefinition(ctx, id)
	case "MessageDefinition":
		impl, ok := w.Concrete.(MessageDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for MessageDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMessageDefinition(ctx, id)
	case "MessageHeader":
		impl, ok := w.Concrete.(MessageHeaderDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for MessageHeader")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMessageHeader(ctx, id)
	case "MolecularSequence":
		impl, ok := w.Concrete.(MolecularSequenceDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for MolecularSequence")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMolecularSequence(ctx, id)
	case "NamingSystem":
		impl, ok := w.Concrete.(NamingSystemDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for NamingSystem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteNamingSystem(ctx, id)
	case "NutritionIntake":
		impl, ok := w.Concrete.(NutritionIntakeDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for NutritionIntake")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteNutritionIntake(ctx, id)
	case "NutritionOrder":
		impl, ok := w.Concrete.(NutritionOrderDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for NutritionOrder")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteNutritionOrder(ctx, id)
	case "NutritionProduct":
		impl, ok := w.Concrete.(NutritionProductDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for NutritionProduct")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteNutritionProduct(ctx, id)
	case "Observation":
		impl, ok := w.Concrete.(ObservationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Observation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteObservation(ctx, id)
	case "ObservationDefinition":
		impl, ok := w.Concrete.(ObservationDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ObservationDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteObservationDefinition(ctx, id)
	case "OperationDefinition":
		impl, ok := w.Concrete.(OperationDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for OperationDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteOperationDefinition(ctx, id)
	case "OperationOutcome":
		impl, ok := w.Concrete.(OperationOutcomeDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for OperationOutcome")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteOperationOutcome(ctx, id)
	case "Organization":
		impl, ok := w.Concrete.(OrganizationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Organization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteOrganization(ctx, id)
	case "OrganizationAffiliation":
		impl, ok := w.Concrete.(OrganizationAffiliationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for OrganizationAffiliation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteOrganizationAffiliation(ctx, id)
	case "PackagedProductDefinition":
		impl, ok := w.Concrete.(PackagedProductDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for PackagedProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePackagedProductDefinition(ctx, id)
	case "Parameters":
		impl, ok := w.Concrete.(ParametersDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Parameters")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteParameters(ctx, id)
	case "Patient":
		impl, ok := w.Concrete.(PatientDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Patient")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePatient(ctx, id)
	case "PaymentNotice":
		impl, ok := w.Concrete.(PaymentNoticeDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for PaymentNotice")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePaymentNotice(ctx, id)
	case "PaymentReconciliation":
		impl, ok := w.Concrete.(PaymentReconciliationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for PaymentReconciliation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePaymentReconciliation(ctx, id)
	case "Permission":
		impl, ok := w.Concrete.(PermissionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Permission")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePermission(ctx, id)
	case "Person":
		impl, ok := w.Concrete.(PersonDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Person")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePerson(ctx, id)
	case "PlanDefinition":
		impl, ok := w.Concrete.(PlanDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for PlanDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePlanDefinition(ctx, id)
	case "Practitioner":
		impl, ok := w.Concrete.(PractitionerDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Practitioner")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePractitioner(ctx, id)
	case "PractitionerRole":
		impl, ok := w.Concrete.(PractitionerRoleDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for PractitionerRole")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePractitionerRole(ctx, id)
	case "Procedure":
		impl, ok := w.Concrete.(ProcedureDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Procedure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteProcedure(ctx, id)
	case "Provenance":
		impl, ok := w.Concrete.(ProvenanceDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Provenance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteProvenance(ctx, id)
	case "Questionnaire":
		impl, ok := w.Concrete.(QuestionnaireDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Questionnaire")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteQuestionnaire(ctx, id)
	case "QuestionnaireResponse":
		impl, ok := w.Concrete.(QuestionnaireResponseDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for QuestionnaireResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteQuestionnaireResponse(ctx, id)
	case "RegulatedAuthorization":
		impl, ok := w.Concrete.(RegulatedAuthorizationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for RegulatedAuthorization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteRegulatedAuthorization(ctx, id)
	case "RelatedPerson":
		impl, ok := w.Concrete.(RelatedPersonDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for RelatedPerson")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteRelatedPerson(ctx, id)
	case "RequestOrchestration":
		impl, ok := w.Concrete.(RequestOrchestrationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for RequestOrchestration")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteRequestOrchestration(ctx, id)
	case "Requirements":
		impl, ok := w.Concrete.(RequirementsDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Requirements")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteRequirements(ctx, id)
	case "ResearchStudy":
		impl, ok := w.Concrete.(ResearchStudyDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ResearchStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteResearchStudy(ctx, id)
	case "ResearchSubject":
		impl, ok := w.Concrete.(ResearchSubjectDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ResearchSubject")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteResearchSubject(ctx, id)
	case "RiskAssessment":
		impl, ok := w.Concrete.(RiskAssessmentDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for RiskAssessment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteRiskAssessment(ctx, id)
	case "Schedule":
		impl, ok := w.Concrete.(ScheduleDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Schedule")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSchedule(ctx, id)
	case "SearchParameter":
		impl, ok := w.Concrete.(SearchParameterDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for SearchParameter")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSearchParameter(ctx, id)
	case "ServiceRequest":
		impl, ok := w.Concrete.(ServiceRequestDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ServiceRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteServiceRequest(ctx, id)
	case "Slot":
		impl, ok := w.Concrete.(SlotDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Slot")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSlot(ctx, id)
	case "Specimen":
		impl, ok := w.Concrete.(SpecimenDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Specimen")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSpecimen(ctx, id)
	case "SpecimenDefinition":
		impl, ok := w.Concrete.(SpecimenDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for SpecimenDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSpecimenDefinition(ctx, id)
	case "StructureDefinition":
		impl, ok := w.Concrete.(StructureDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for StructureDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteStructureDefinition(ctx, id)
	case "StructureMap":
		impl, ok := w.Concrete.(StructureMapDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for StructureMap")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteStructureMap(ctx, id)
	case "Subscription":
		impl, ok := w.Concrete.(SubscriptionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Subscription")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubscription(ctx, id)
	case "SubscriptionStatus":
		impl, ok := w.Concrete.(SubscriptionStatusDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for SubscriptionStatus")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubscriptionStatus(ctx, id)
	case "SubscriptionTopic":
		impl, ok := w.Concrete.(SubscriptionTopicDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for SubscriptionTopic")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubscriptionTopic(ctx, id)
	case "Substance":
		impl, ok := w.Concrete.(SubstanceDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Substance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstance(ctx, id)
	case "SubstanceDefinition":
		impl, ok := w.Concrete.(SubstanceDefinitionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for SubstanceDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstanceDefinition(ctx, id)
	case "SubstanceNucleicAcid":
		impl, ok := w.Concrete.(SubstanceNucleicAcidDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for SubstanceNucleicAcid")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstanceNucleicAcid(ctx, id)
	case "SubstancePolymer":
		impl, ok := w.Concrete.(SubstancePolymerDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for SubstancePolymer")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstancePolymer(ctx, id)
	case "SubstanceProtein":
		impl, ok := w.Concrete.(SubstanceProteinDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for SubstanceProtein")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstanceProtein(ctx, id)
	case "SubstanceReferenceInformation":
		impl, ok := w.Concrete.(SubstanceReferenceInformationDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for SubstanceReferenceInformation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstanceReferenceInformation(ctx, id)
	case "SubstanceSourceMaterial":
		impl, ok := w.Concrete.(SubstanceSourceMaterialDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for SubstanceSourceMaterial")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstanceSourceMaterial(ctx, id)
	case "SupplyDelivery":
		impl, ok := w.Concrete.(SupplyDeliveryDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for SupplyDelivery")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSupplyDelivery(ctx, id)
	case "SupplyRequest":
		impl, ok := w.Concrete.(SupplyRequestDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for SupplyRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSupplyRequest(ctx, id)
	case "Task":
		impl, ok := w.Concrete.(TaskDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Task")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteTask(ctx, id)
	case "TerminologyCapabilities":
		impl, ok := w.Concrete.(TerminologyCapabilitiesDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for TerminologyCapabilities")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteTerminologyCapabilities(ctx, id)
	case "TestPlan":
		impl, ok := w.Concrete.(TestPlanDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for TestPlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteTestPlan(ctx, id)
	case "TestReport":
		impl, ok := w.Concrete.(TestReportDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for TestReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteTestReport(ctx, id)
	case "TestScript":
		impl, ok := w.Concrete.(TestScriptDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for TestScript")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteTestScript(ctx, id)
	case "Transport":
		impl, ok := w.Concrete.(TransportDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for Transport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteTransport(ctx, id)
	case "ValueSet":
		impl, ok := w.Concrete.(ValueSetDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for ValueSet")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteValueSet(ctx, id)
	case "VerificationResult":
		impl, ok := w.Concrete.(VerificationResultDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for VerificationResult")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteVerificationResult(ctx, id)
	case "VisionPrescription":
		impl, ok := w.Concrete.(VisionPrescriptionDelete)
		if !ok {
			return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("delete not implemented for VisionPrescription")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteVisionPrescription(ctx, id)
	default:
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("invalid resource type: " + resourceType)},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
}
func (w Generic) Search(ctx context.Context, resourceType string, options search.Options) (search.Result[model.Resource], error) {
	g, ok := w.Concrete.(capabilities.GenericSearch)
	if ok {
		// shortcut for the case that the underlying implementation already implements the generic API
		return g.Search(ctx, resourceType, options)
	}
	switch resourceType {
	case "Account":
		impl, ok := w.Concrete.(AccountSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Account")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchAccount(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ActivityDefinition":
		impl, ok := w.Concrete.(ActivityDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ActivityDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchActivityDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ActorDefinition":
		impl, ok := w.Concrete.(ActorDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ActorDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchActorDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "AdministrableProductDefinition":
		impl, ok := w.Concrete.(AdministrableProductDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for AdministrableProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchAdministrableProductDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "AdverseEvent":
		impl, ok := w.Concrete.(AdverseEventSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for AdverseEvent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchAdverseEvent(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "AllergyIntolerance":
		impl, ok := w.Concrete.(AllergyIntoleranceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for AllergyIntolerance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchAllergyIntolerance(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Appointment":
		impl, ok := w.Concrete.(AppointmentSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Appointment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchAppointment(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "AppointmentResponse":
		impl, ok := w.Concrete.(AppointmentResponseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for AppointmentResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchAppointmentResponse(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ArtifactAssessment":
		impl, ok := w.Concrete.(ArtifactAssessmentSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ArtifactAssessment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchArtifactAssessment(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "AuditEvent":
		impl, ok := w.Concrete.(AuditEventSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for AuditEvent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchAuditEvent(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Basic":
		impl, ok := w.Concrete.(BasicSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Basic")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchBasic(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Binary":
		impl, ok := w.Concrete.(BinarySearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Binary")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchBinary(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "BiologicallyDerivedProduct":
		impl, ok := w.Concrete.(BiologicallyDerivedProductSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for BiologicallyDerivedProduct")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchBiologicallyDerivedProduct(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "BiologicallyDerivedProductDispense":
		impl, ok := w.Concrete.(BiologicallyDerivedProductDispenseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for BiologicallyDerivedProductDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchBiologicallyDerivedProductDispense(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "BodyStructure":
		impl, ok := w.Concrete.(BodyStructureSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for BodyStructure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchBodyStructure(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Bundle":
		impl, ok := w.Concrete.(BundleSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Bundle")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchBundle(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CapabilityStatement":
		impl, ok := w.Concrete.(CapabilityStatementSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for CapabilityStatement")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCapabilityStatement(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CarePlan":
		impl, ok := w.Concrete.(CarePlanSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for CarePlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCarePlan(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CareTeam":
		impl, ok := w.Concrete.(CareTeamSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for CareTeam")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCareTeam(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ChargeItem":
		impl, ok := w.Concrete.(ChargeItemSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ChargeItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchChargeItem(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ChargeItemDefinition":
		impl, ok := w.Concrete.(ChargeItemDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ChargeItemDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchChargeItemDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Citation":
		impl, ok := w.Concrete.(CitationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Citation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCitation(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Claim":
		impl, ok := w.Concrete.(ClaimSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Claim")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchClaim(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ClaimResponse":
		impl, ok := w.Concrete.(ClaimResponseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ClaimResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchClaimResponse(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ClinicalImpression":
		impl, ok := w.Concrete.(ClinicalImpressionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ClinicalImpression")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchClinicalImpression(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ClinicalUseDefinition":
		impl, ok := w.Concrete.(ClinicalUseDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ClinicalUseDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchClinicalUseDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CodeSystem":
		impl, ok := w.Concrete.(CodeSystemSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for CodeSystem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCodeSystem(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Communication":
		impl, ok := w.Concrete.(CommunicationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Communication")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCommunication(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CommunicationRequest":
		impl, ok := w.Concrete.(CommunicationRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for CommunicationRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCommunicationRequest(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CompartmentDefinition":
		impl, ok := w.Concrete.(CompartmentDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for CompartmentDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCompartmentDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Composition":
		impl, ok := w.Concrete.(CompositionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Composition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchComposition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ConceptMap":
		impl, ok := w.Concrete.(ConceptMapSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ConceptMap")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchConceptMap(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Condition":
		impl, ok := w.Concrete.(ConditionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Condition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCondition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ConditionDefinition":
		impl, ok := w.Concrete.(ConditionDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ConditionDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchConditionDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Consent":
		impl, ok := w.Concrete.(ConsentSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Consent")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchConsent(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Contract":
		impl, ok := w.Concrete.(ContractSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Contract")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchContract(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Coverage":
		impl, ok := w.Concrete.(CoverageSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Coverage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCoverage(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CoverageEligibilityRequest":
		impl, ok := w.Concrete.(CoverageEligibilityRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for CoverageEligibilityRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCoverageEligibilityRequest(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CoverageEligibilityResponse":
		impl, ok := w.Concrete.(CoverageEligibilityResponseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for CoverageEligibilityResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCoverageEligibilityResponse(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DetectedIssue":
		impl, ok := w.Concrete.(DetectedIssueSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for DetectedIssue")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDetectedIssue(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Device":
		impl, ok := w.Concrete.(DeviceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Device")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDevice(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DeviceAssociation":
		impl, ok := w.Concrete.(DeviceAssociationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for DeviceAssociation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDeviceAssociation(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DeviceDefinition":
		impl, ok := w.Concrete.(DeviceDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for DeviceDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDeviceDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DeviceDispense":
		impl, ok := w.Concrete.(DeviceDispenseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for DeviceDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDeviceDispense(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DeviceMetric":
		impl, ok := w.Concrete.(DeviceMetricSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for DeviceMetric")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDeviceMetric(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DeviceRequest":
		impl, ok := w.Concrete.(DeviceRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for DeviceRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDeviceRequest(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DeviceUsage":
		impl, ok := w.Concrete.(DeviceUsageSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for DeviceUsage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDeviceUsage(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DiagnosticReport":
		impl, ok := w.Concrete.(DiagnosticReportSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for DiagnosticReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDiagnosticReport(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DocumentReference":
		impl, ok := w.Concrete.(DocumentReferenceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for DocumentReference")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDocumentReference(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Encounter":
		impl, ok := w.Concrete.(EncounterSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Encounter")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEncounter(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "EncounterHistory":
		impl, ok := w.Concrete.(EncounterHistorySearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for EncounterHistory")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEncounterHistory(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Endpoint":
		impl, ok := w.Concrete.(EndpointSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Endpoint")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEndpoint(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "EnrollmentRequest":
		impl, ok := w.Concrete.(EnrollmentRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for EnrollmentRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEnrollmentRequest(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "EnrollmentResponse":
		impl, ok := w.Concrete.(EnrollmentResponseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for EnrollmentResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEnrollmentResponse(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "EpisodeOfCare":
		impl, ok := w.Concrete.(EpisodeOfCareSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for EpisodeOfCare")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEpisodeOfCare(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "EventDefinition":
		impl, ok := w.Concrete.(EventDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for EventDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEventDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Evidence":
		impl, ok := w.Concrete.(EvidenceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Evidence")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEvidence(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "EvidenceReport":
		impl, ok := w.Concrete.(EvidenceReportSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for EvidenceReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEvidenceReport(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "EvidenceVariable":
		impl, ok := w.Concrete.(EvidenceVariableSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for EvidenceVariable")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEvidenceVariable(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ExampleScenario":
		impl, ok := w.Concrete.(ExampleScenarioSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ExampleScenario")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchExampleScenario(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ExplanationOfBenefit":
		impl, ok := w.Concrete.(ExplanationOfBenefitSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ExplanationOfBenefit")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchExplanationOfBenefit(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "FamilyMemberHistory":
		impl, ok := w.Concrete.(FamilyMemberHistorySearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for FamilyMemberHistory")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchFamilyMemberHistory(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Flag":
		impl, ok := w.Concrete.(FlagSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Flag")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchFlag(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "FormularyItem":
		impl, ok := w.Concrete.(FormularyItemSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for FormularyItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchFormularyItem(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "GenomicStudy":
		impl, ok := w.Concrete.(GenomicStudySearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for GenomicStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchGenomicStudy(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Goal":
		impl, ok := w.Concrete.(GoalSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Goal")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchGoal(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "GraphDefinition":
		impl, ok := w.Concrete.(GraphDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for GraphDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchGraphDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Group":
		impl, ok := w.Concrete.(GroupSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Group")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchGroup(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "GuidanceResponse":
		impl, ok := w.Concrete.(GuidanceResponseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for GuidanceResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchGuidanceResponse(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "HealthcareService":
		impl, ok := w.Concrete.(HealthcareServiceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for HealthcareService")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchHealthcareService(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ImagingSelection":
		impl, ok := w.Concrete.(ImagingSelectionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ImagingSelection")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchImagingSelection(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ImagingStudy":
		impl, ok := w.Concrete.(ImagingStudySearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ImagingStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchImagingStudy(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Immunization":
		impl, ok := w.Concrete.(ImmunizationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Immunization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchImmunization(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ImmunizationEvaluation":
		impl, ok := w.Concrete.(ImmunizationEvaluationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ImmunizationEvaluation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchImmunizationEvaluation(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ImmunizationRecommendation":
		impl, ok := w.Concrete.(ImmunizationRecommendationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ImmunizationRecommendation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchImmunizationRecommendation(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ImplementationGuide":
		impl, ok := w.Concrete.(ImplementationGuideSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ImplementationGuide")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchImplementationGuide(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Ingredient":
		impl, ok := w.Concrete.(IngredientSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Ingredient")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchIngredient(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "InsurancePlan":
		impl, ok := w.Concrete.(InsurancePlanSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for InsurancePlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchInsurancePlan(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "InventoryItem":
		impl, ok := w.Concrete.(InventoryItemSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for InventoryItem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchInventoryItem(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "InventoryReport":
		impl, ok := w.Concrete.(InventoryReportSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for InventoryReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchInventoryReport(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Invoice":
		impl, ok := w.Concrete.(InvoiceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Invoice")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchInvoice(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Library":
		impl, ok := w.Concrete.(LibrarySearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Library")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchLibrary(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Linkage":
		impl, ok := w.Concrete.(LinkageSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Linkage")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchLinkage(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "List":
		impl, ok := w.Concrete.(ListSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for List")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchList(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Location":
		impl, ok := w.Concrete.(LocationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Location")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchLocation(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ManufacturedItemDefinition":
		impl, ok := w.Concrete.(ManufacturedItemDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ManufacturedItemDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchManufacturedItemDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Measure":
		impl, ok := w.Concrete.(MeasureSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Measure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMeasure(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MeasureReport":
		impl, ok := w.Concrete.(MeasureReportSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for MeasureReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMeasureReport(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Medication":
		impl, ok := w.Concrete.(MedicationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Medication")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedication(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicationAdministration":
		impl, ok := w.Concrete.(MedicationAdministrationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for MedicationAdministration")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicationAdministration(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicationDispense":
		impl, ok := w.Concrete.(MedicationDispenseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for MedicationDispense")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicationDispense(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicationKnowledge":
		impl, ok := w.Concrete.(MedicationKnowledgeSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for MedicationKnowledge")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicationKnowledge(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicationRequest":
		impl, ok := w.Concrete.(MedicationRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for MedicationRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicationRequest(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicationStatement":
		impl, ok := w.Concrete.(MedicationStatementSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for MedicationStatement")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicationStatement(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicinalProductDefinition":
		impl, ok := w.Concrete.(MedicinalProductDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for MedicinalProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicinalProductDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MessageDefinition":
		impl, ok := w.Concrete.(MessageDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for MessageDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMessageDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MessageHeader":
		impl, ok := w.Concrete.(MessageHeaderSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for MessageHeader")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMessageHeader(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MolecularSequence":
		impl, ok := w.Concrete.(MolecularSequenceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for MolecularSequence")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMolecularSequence(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "NamingSystem":
		impl, ok := w.Concrete.(NamingSystemSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for NamingSystem")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchNamingSystem(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "NutritionIntake":
		impl, ok := w.Concrete.(NutritionIntakeSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for NutritionIntake")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchNutritionIntake(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "NutritionOrder":
		impl, ok := w.Concrete.(NutritionOrderSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for NutritionOrder")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchNutritionOrder(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "NutritionProduct":
		impl, ok := w.Concrete.(NutritionProductSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for NutritionProduct")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchNutritionProduct(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Observation":
		impl, ok := w.Concrete.(ObservationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Observation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchObservation(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ObservationDefinition":
		impl, ok := w.Concrete.(ObservationDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ObservationDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchObservationDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "OperationDefinition":
		impl, ok := w.Concrete.(OperationDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for OperationDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchOperationDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "OperationOutcome":
		impl, ok := w.Concrete.(OperationOutcomeSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for OperationOutcome")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchOperationOutcome(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Organization":
		impl, ok := w.Concrete.(OrganizationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Organization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchOrganization(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "OrganizationAffiliation":
		impl, ok := w.Concrete.(OrganizationAffiliationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for OrganizationAffiliation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchOrganizationAffiliation(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "PackagedProductDefinition":
		impl, ok := w.Concrete.(PackagedProductDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for PackagedProductDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPackagedProductDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Parameters":
		impl, ok := w.Concrete.(ParametersSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Parameters")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchParameters(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Patient":
		impl, ok := w.Concrete.(PatientSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Patient")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPatient(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "PaymentNotice":
		impl, ok := w.Concrete.(PaymentNoticeSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for PaymentNotice")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPaymentNotice(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "PaymentReconciliation":
		impl, ok := w.Concrete.(PaymentReconciliationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for PaymentReconciliation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPaymentReconciliation(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Permission":
		impl, ok := w.Concrete.(PermissionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Permission")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPermission(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Person":
		impl, ok := w.Concrete.(PersonSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Person")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPerson(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "PlanDefinition":
		impl, ok := w.Concrete.(PlanDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for PlanDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPlanDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Practitioner":
		impl, ok := w.Concrete.(PractitionerSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Practitioner")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPractitioner(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "PractitionerRole":
		impl, ok := w.Concrete.(PractitionerRoleSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for PractitionerRole")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPractitionerRole(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Procedure":
		impl, ok := w.Concrete.(ProcedureSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Procedure")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchProcedure(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Provenance":
		impl, ok := w.Concrete.(ProvenanceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Provenance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchProvenance(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Questionnaire":
		impl, ok := w.Concrete.(QuestionnaireSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Questionnaire")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchQuestionnaire(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "QuestionnaireResponse":
		impl, ok := w.Concrete.(QuestionnaireResponseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for QuestionnaireResponse")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchQuestionnaireResponse(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "RegulatedAuthorization":
		impl, ok := w.Concrete.(RegulatedAuthorizationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for RegulatedAuthorization")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchRegulatedAuthorization(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "RelatedPerson":
		impl, ok := w.Concrete.(RelatedPersonSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for RelatedPerson")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchRelatedPerson(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "RequestOrchestration":
		impl, ok := w.Concrete.(RequestOrchestrationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for RequestOrchestration")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchRequestOrchestration(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Requirements":
		impl, ok := w.Concrete.(RequirementsSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Requirements")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchRequirements(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ResearchStudy":
		impl, ok := w.Concrete.(ResearchStudySearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ResearchStudy")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchResearchStudy(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ResearchSubject":
		impl, ok := w.Concrete.(ResearchSubjectSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ResearchSubject")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchResearchSubject(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "RiskAssessment":
		impl, ok := w.Concrete.(RiskAssessmentSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for RiskAssessment")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchRiskAssessment(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Schedule":
		impl, ok := w.Concrete.(ScheduleSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Schedule")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSchedule(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SearchParameter":
		impl, ok := w.Concrete.(SearchParameterSearch)
		if ok {
			result, err := impl.SearchSearchParameter(ctx, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		// Fallback: gather SearchParameter from SearchCapabilities methods if SearchSearchParameter not implemented
		// Get base URL from CapabilityStatement for canonical references
		capabilityStatement, err := w.Concrete.CapabilityBase(ctx)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		var baseUrl string
		if capabilityStatement.Implementation != nil && capabilityStatement.Implementation.Url != nil && capabilityStatement.Implementation.Url.Value != nil {
			baseUrl = *capabilityStatement.Implementation.Url.Value
		}
		searchParameters, err := searchParameters(ctx, w.Concrete, baseUrl)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		filteredParameters := make(map[string]r5.SearchParameter)
		for id, searchParam := range searchParameters {
			filteredParameters[id] = searchParam
		}
		if idParams, ok := options.Parameters[search.ParameterKey{Name: "_id"}]; ok {
			filteredParameters = make(map[string]r5.SearchParameter)
			for _, idValues := range idParams {
				for _, idValue := range idValues {
					idStr := idValue.String()
					if searchParam, exists := searchParameters[idStr]; exists {
						filteredParameters[idStr] = searchParam
					}
				}
			}
		}
		resources := make([]model.Resource, 0, len(filteredParameters))
		for _, searchParam := range filteredParameters {
			resources = append(resources, searchParam)
		}
		return search.Result[model.Resource]{

			Included:  []model.Resource{},
			Next:      search.Cursor(""),
			Resources: resources,
		}, nil
	case "ServiceRequest":
		impl, ok := w.Concrete.(ServiceRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ServiceRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchServiceRequest(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Slot":
		impl, ok := w.Concrete.(SlotSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Slot")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSlot(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Specimen":
		impl, ok := w.Concrete.(SpecimenSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Specimen")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSpecimen(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SpecimenDefinition":
		impl, ok := w.Concrete.(SpecimenDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for SpecimenDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSpecimenDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "StructureDefinition":
		impl, ok := w.Concrete.(StructureDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for StructureDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchStructureDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "StructureMap":
		impl, ok := w.Concrete.(StructureMapSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for StructureMap")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchStructureMap(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Subscription":
		impl, ok := w.Concrete.(SubscriptionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Subscription")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubscription(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubscriptionStatus":
		impl, ok := w.Concrete.(SubscriptionStatusSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for SubscriptionStatus")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubscriptionStatus(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubscriptionTopic":
		impl, ok := w.Concrete.(SubscriptionTopicSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for SubscriptionTopic")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubscriptionTopic(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Substance":
		impl, ok := w.Concrete.(SubstanceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Substance")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstance(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubstanceDefinition":
		impl, ok := w.Concrete.(SubstanceDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for SubstanceDefinition")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstanceDefinition(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubstanceNucleicAcid":
		impl, ok := w.Concrete.(SubstanceNucleicAcidSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for SubstanceNucleicAcid")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstanceNucleicAcid(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubstancePolymer":
		impl, ok := w.Concrete.(SubstancePolymerSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for SubstancePolymer")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstancePolymer(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubstanceProtein":
		impl, ok := w.Concrete.(SubstanceProteinSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for SubstanceProtein")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstanceProtein(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubstanceReferenceInformation":
		impl, ok := w.Concrete.(SubstanceReferenceInformationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for SubstanceReferenceInformation")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstanceReferenceInformation(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubstanceSourceMaterial":
		impl, ok := w.Concrete.(SubstanceSourceMaterialSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for SubstanceSourceMaterial")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstanceSourceMaterial(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SupplyDelivery":
		impl, ok := w.Concrete.(SupplyDeliverySearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for SupplyDelivery")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSupplyDelivery(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SupplyRequest":
		impl, ok := w.Concrete.(SupplyRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for SupplyRequest")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSupplyRequest(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Task":
		impl, ok := w.Concrete.(TaskSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Task")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchTask(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "TerminologyCapabilities":
		impl, ok := w.Concrete.(TerminologyCapabilitiesSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for TerminologyCapabilities")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchTerminologyCapabilities(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "TestPlan":
		impl, ok := w.Concrete.(TestPlanSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for TestPlan")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchTestPlan(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "TestReport":
		impl, ok := w.Concrete.(TestReportSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for TestReport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchTestReport(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "TestScript":
		impl, ok := w.Concrete.(TestScriptSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for TestScript")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchTestScript(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Transport":
		impl, ok := w.Concrete.(TransportSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for Transport")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchTransport(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ValueSet":
		impl, ok := w.Concrete.(ValueSetSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for ValueSet")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchValueSet(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "VerificationResult":
		impl, ok := w.Concrete.(VerificationResultSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for VerificationResult")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchVerificationResult(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "VisionPrescription":
		impl, ok := w.Concrete.(VisionPrescriptionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r5.String{Value: ptr.To("search not implemented for VisionPrescription")},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchVisionPrescription(ctx, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	default:
		return search.Result[model.Resource]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("invalid resource type: " + resourceType)},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
}
