// DO NOT EDIT!
// Code generated by "github.com/DAMEDIC/fhir-toolbox-go/internal/generate";
// use `make generate` to regenerate.

// Package basic provides basic resources that are valid across FHIR versions.
package basic

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
	fhirpath "github.com/DAMEDIC/fhir-toolbox-go/fhirpath"
	"reflect"
	"strings"
)

// RawResource represents a FHIR resource as raw content (JSON or XML)
type RawResource struct {
	Content string
	IsJSON  bool
	IsXML   bool
}

// MemSize returns the memory size of the RawResource
func (r RawResource) MemSize() int {
	return len(r.Content) + int(reflect.TypeOf(r).Size())
}

// ResourceType returns the resource type from the raw content
func (r RawResource) ResourceType() string {
	if r.IsJSON {
		var t struct {
			ResourceType string `json:"resourceType"`
		}
		err := json.Unmarshal([]byte(r.Content), &t)
		if err == nil && t.ResourceType != "" {
			return t.ResourceType
		}
	} else if r.IsXML {
		d := xml.NewDecoder(strings.NewReader(r.Content))
		for {
			token, err := d.Token()
			if err != nil {
				break
			}
			if start, ok := token.(xml.StartElement); ok {
				return start.Name.Local
			}
		}
	}
	return "RawResource"
}

// ResourceId returns the resource ID if present
func (r RawResource) ResourceId() (string, bool) {
	if r.IsJSON {
		var t struct {
			Id string `json:"id"`
		}
		err := json.Unmarshal([]byte(r.Content), &t)
		if err == nil && t.Id != "" {
			return t.Id, true
		}
	} else if r.IsXML {
		d := xml.NewDecoder(strings.NewReader(r.Content))
		for {
			token, err := d.Token()
			if err != nil {
				break
			}
			if start, ok := token.(xml.StartElement); ok {
				for _, attr := range start.Attr {
					if attr.Name.Local == "id" && attr.Value != "" {
						return attr.Value, true
					}
				}
			}
		}
	}
	return "", false
}

// Children returns child elements for FHIRPath evaluation
func (r RawResource) Children(name ...string) fhirpath.Collection {
	return nil
}

// ToBoolean converts to Boolean for FHIRPath
func (r RawResource) ToBoolean(explicit bool) (fhirpath.Boolean, bool, error) {
	return false, false, fmt.Errorf("cannot convert RawResource to Boolean")
}

// ToString converts to String for FHIRPath
func (r RawResource) ToString(explicit bool) (fhirpath.String, bool, error) {
	return fhirpath.String(r.Content), true, nil
}

// ToInteger converts to Integer for FHIRPath
func (r RawResource) ToInteger(explicit bool) (fhirpath.Integer, bool, error) {
	return 0, false, fmt.Errorf("cannot convert RawResource to Integer")
}

// ToDecimal converts to Decimal for FHIRPath
func (r RawResource) ToDecimal(explicit bool) (fhirpath.Decimal, bool, error) {
	return fhirpath.Decimal{}, false, fmt.Errorf("cannot convert RawResource to Decimal")
}

// ToDate converts to Date for FHIRPath
func (r RawResource) ToDate(explicit bool) (fhirpath.Date, bool, error) {
	return fhirpath.Date{}, false, fmt.Errorf("cannot convert RawResource to Date")
}

// ToTime converts to Time for FHIRPath
func (r RawResource) ToTime(explicit bool) (fhirpath.Time, bool, error) {
	return fhirpath.Time{}, false, fmt.Errorf("cannot convert RawResource to Time")
}

// ToDateTime converts to DateTime for FHIRPath
func (r RawResource) ToDateTime(explicit bool) (fhirpath.DateTime, bool, error) {
	return fhirpath.DateTime{}, false, fmt.Errorf("cannot convert RawResource to DateTime")
}

// ToQuantity converts to Quantity for FHIRPath
func (r RawResource) ToQuantity(explicit bool) (fhirpath.Quantity, bool, error) {
	return fhirpath.Quantity{}, false, fmt.Errorf("cannot convert RawResource to Quantity")
}

// Equal compares with another Element for FHIRPath
func (r RawResource) Equal(other fhirpath.Element, _noReverseTypeConversion ...bool) (bool, bool) {
	s, ok, _ := r.ToString(false)
	if !ok {
		return false, true
	}
	os, ok, _ := other.ToString(false)
	if !ok {
		return false, true
	}
	return s.Equal(os)
}

// Equivalent checks equivalence with another Element for FHIRPath
func (r RawResource) Equivalent(other fhirpath.Element, _noReverseTypeConversion ...bool) bool {
	eq, ok := r.Equal(other)
	return eq && ok
}

// TypeInfo returns type information for FHIRPath
func (r RawResource) TypeInfo() fhirpath.TypeInfo {
	return fhirpath.ClassInfo{
		Name:      "RawResource",
		Namespace: "FHIR",
	}
}

// MarshalJSON marshals the raw resource content
func (r RawResource) MarshalJSON() ([]byte, error) {
	if r.IsJSON {
		return []byte(r.Content), nil
	}
	return nil, fmt.Errorf("cannot marshal XML content as JSON")
}

// UnmarshalJSON unmarshals JSON content into the raw resource
func (r *RawResource) UnmarshalJSON(data []byte) error {
	r.Content = string(data)
	r.IsJSON = true
	r.IsXML = false
	return nil
}

// String returns the raw resource content as a string
func (r RawResource) String() string {
	return r.Content
}

// MarshalXML marshals the raw resource content as XML
func (r RawResource) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if r.IsXML {
		var elem interface{}
		err := xml.Unmarshal([]byte(r.Content), &elem)
		if err != nil {
			return err
		}
		return e.Encode(elem)
	}
	return fmt.Errorf("cannot marshal JSON content as XML")
}

// UnmarshalXML unmarshals XML content into the raw resource
func (r *RawResource) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var elem interface{}
	err := d.DecodeElement(&elem, &start)
	if err != nil {
		return err
	}
	var raw bytes.Buffer
	err = xml.NewEncoder(&raw).Encode(elem)
	if err != nil {
		return err
	}
	r.Content = raw.String()
	r.IsJSON = false
	r.IsXML = true
	return nil
}
